---
title: "Introduction to MECfda Package"
author: 
 - name: "Heyang Ji"
 - name: "Yuanyuan Luan"
 - name: "Xiwei Chen"
output: rmarkdown::html_vignette
bibliography: references.bib
nocite: |
  '@*'
abstract: 
  "Functional data analysis is an important technique to analyze high dimensional data, 
  which is treat some variables as functions. 
  This technique is very commonly use in scenario like analyzing physical activity data 
  generated by wearable devices. 
  Scalar-on-function linear regression model is an important type in functional data analysis,
  which havs scalar-valued response variable and one or multiple function-valued covariates.  
  Package MECfda provide functions that sovle a variaty of scalar-on-function linear regression models,
  including generalized mixed effect scalar-on-function linear models and 
  scalar-on-function quantile linear regression models. 
  Physical activity data generated by wearable devices usually have measurement error, 
  which lead to bias in parameter estimation. 
  Package MECfda also provides several bias correction methods to address this problem. 
  "
keywords: 
  "scalar-on-function regression, functional data, measurement error, function-valued covariates."
vignette: >
  %\VignetteIndexEntry{Introduction to MECfda Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- output: pdf_document -->
<!-- output: rmarkdown::html_vignette -->
<!-- output: html_document -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```



# Introduction

Functional data analysis is a commonly used technique when the data are very high dimensional. 
We treat some variables in the dataset as function (of time, usually) and utilize the 
infinite dimensionality of function space to provide enough degree of freedom in statistical model 
so that we can capture the complicated distribution pattern due to the high dimensionality of the data. 
Scalar-on-function linear regression model is an important model of in functional data analysis,
in which the response variable is scalar-valued and one or multiple function-valued covariates are included. 

One of the scenario where functional data analysis is most commonly used is analysis of physical activity data collected by wearable devices. 
An important problem in physical activity data collected by wearable devices is that such data usually have measurement error, which lead to bias in parameter estimation.

Our aim is to develop an R package that can solve all kinds of 
scalar-on-function linear regression models and 
include some developed estimation methods that correct the bias
due to measurement error in scalar-on-function linear regression models. 

```{r setup}
library(MECfda)
```

# Scalar-on-function Linear Regression Models

The generic form of scalar-on-function linear regression model is
$$T(F_{Y_i|X_i,Z_i}) =  \sum_{l=1}^{L} \int_{\Omega_l} \beta_l(t) X_{li}(t) dt + (1,Z_i^T)\gamma$$
where 
$Y_i$ represents the scalar-valued response variable, 
$X_{li}(t)$ represents the function-valued covariates ($l=1,\dots,L$), 
$\beta_l$ and $X_{li}$ ($t\in\Omega_l$) are in $L^2(\Omega_l)$,
$Z_i = (Z_{1i},\dots,Z_{qi})^T$ represents the scalar valued covariates,
$\gamma = (\gamma_0,\gamma_1,\dots,\gamma_q)^T$,
$F_{Y_i|X_i,Z_i}$ represents the CDF of the $Y_i$ given $X_i$ and $Z_i$, 
$T(\cdot)$ is a statistical functional. 

In ordinary scalar-on-function generalized linear (mixed) models,
$$T(F_{Y_i|X_i,Z_i}) = g\left\{\int_\mathbb{R}ydF_{Y_i|X_i,Z_i}(y)\right\} = g(E[Y_i|X_i,Z_i]),$$ 
where $g(\cdot)$ is a link function. 

In scalar-on-function quantile linear regression models,
$$T(F_{Y_i|X_i,Z_i}) = Q_{Y_i|X_i,Z_i}(\tau) = F_{Y_i|X_i,Z_i}^{-1}(\tau),$$ 
where $F_{Y_i|X_i,Z_i}^{-1}(\cdot)$ is the inverse of $F_{Y_i|X_i,Z_i}(\cdot)$, $\tau\in(0,1)$. 

## Functional Data

Function-valued variables (functional variables) are usually recorded by the 
value of the function(s) at some certain (time) points in its domain. 
The data of a function variable is often in a form of a matrix 
$(x_{ij})_{n\times m}$, 
where $x_{ij} = f_i(t_j)$, represents the value of $f_i(t_j)$, 
each row represent an observation (subject), 
each column is corresponding to a measurement (time) point.

#### S4 class ***functional_variable***

In MECfda package, we have a s4 class, ***functional_variable*** that represents
the data of a functional variable in this matrix form. 
The class has a slot ***X*** for matrix $(x_{ij})_{n\times m}$, 
and slots ***t_0*** and ***period*** for the left end and length of the
domain of the functional variable
and slot ***t_points*** (time) points that the functional variable is measured. 
And a method ***dim*** is provided to return the number of subject(s)
and measurement (time) points of a ***functional_variable*** object. 

```{r fd}
fv = functional_variable(
  X = matrix(rnorm(10*24),10,24),
  t_0 = 0,
  period = 1,
  t_points = (0:9)/10
)
dim(fv)
```

## Basis Expansion

$\{\rho_{k}\}_{k=1}^\infty$ is a basis sequence of $L^2(\Omega)$. 
For an arbitrary function-valued parameter $\beta(\cdot)\in L^2(\Omega)$, 
there exist number sequence $\{c_{k}\}_{k=1}^\infty$ s.t. 
$$\beta(t) = \sum_{k=1}^\infty c_{k}\rho_{k}(t)$$
and for a function-valued variable $X_i(t)$,
$$\int_\Omega\beta(t) X_i(t) dt 
= \int_\Omega X_i(t) \sum_{k=1}^\infty c_{k}\rho_{k}(t) dt
= \sum_{k=1}^\infty c_{k} \int_\Omega \rho_{k}(t) X_i(t) dt
$$
We do a truncation for the infinite basis sequence, then
$$\int_\Omega\beta(t) X_i(t) dt \approx \sum_{k=1}^K c_{k} \int_\Omega X_i(t) \rho_{k}(t) dt$$
For statistical models with part(s) in the form of 
$\int_\Omega\beta(t) X_i(t) dt$
we use
$c_{k} \int_\Omega X_i(t) \rho_{k}(t) dt$
to approximate
$\int_\Omega\beta(t) X_i(t) dt$
and treat 
$\int_{\Omega} \rho_{k}(t) X_{i}(t) dt$
as the variables, 
then the scalar-on-function linear models is converted to a ordinary scalar-on-scalar linear model,
and problem of estimating $\beta(t)$ is converted to estimating $c_k$, $k=1,\dots p$. 

In practice, we may not necessarily use the truncated complete basis of $L^2$ function space, 
we can just use a finite sequence of linearly independent functions as the basis function. 


Performing basis expansion methods to data of functional variable in matrix form as we mentioned
is to compute $(b_{ik})_{n\times p}$, 
where $b_{ik} = \int_\Omega f(t)\rho_k(t) dt$.

Usually the domain $\Omega$ of a function-valued variable $\{X(t),t\in\Omega\}$ is an interval. 
And the commonly used basis sequence types includes Fourier basis, b-splines basis, and eigen function basis. 

### Fourier basis

The Fourier basis of $L^2([t_0,t_0+T])$ consists of
$$\frac{1}{2},\ \cos(\frac{2\pi}{T}k[x-t_0]),\ \sin (\frac{2\pi}{T}k[x-t_0])$$
where $k = 1,\dots,\infty$.

#### S4 class ***Fourier_series***

In MECfda package, we have a s4 class, ***Fourier_series*** that represents
the linear combination of Fourier basis functions
$$\frac{a_0}{2} + \sum_{k=1}^{p_a} a_k \cos{(\frac{2\pi}{T}k(x-t_0))} + 
\sum_{k=1}^{p_b} b_k \sin{(\frac{2\pi}{T}k(x-t_0))},\qquad x\in[t_0,t_0+T].$$
Slot ***double_constant*** is the value of $a_0$. 
Slot ***cos*** contains the values of coefficients of $\cos$ waves, $a_k$. 
Slot ***sin*** contains the values of coefficients of $\sin$ waves, $b_k$. 
Slot ***k_cos*** values of $k$ corresponding to the coefficients of $\cos$ waves. 
Slot ***k_sin*** values of $k$ corresponding to the coefficients of $\sin$ waves. 
Slot ***t_0*** is the left end of the domain interval, $t_0$.
Slot ***period*** is length of the domain interval, $T$.

Method ***plot*** for class ***Fourier_series*** is provided to draw the image of the summation function. 
Method ***FourierSeries2fun*** is provided to compute the value of the summation function. 
Argument ***object***	should be an object of ***Fourier_series*** class.
Argument ***t*** is the value of independent variable $t$. 
Method ***extractCoef*** is provided to extract the Fourier coefficients of ***Fourier_series*** class object. 

```{r c1}
fsc = Fourier_series(
  double_constant = 3,
  cos = c(0,2/3),
  sin = c(1,7/5),
  k_cos = 1:2,
  k_sin = 1:2,
  t_0 = 0,
  period = 1
)
plot(fsc)
FourierSeries2fun(fsc,seq(0,1,0.05))
extractCoef(fsc)
```

The object ***fsc*** represents the summation
$$\frac32 + \frac23 \cos(2\pi\cdot2x) + \sin(2\pi x) + \frac75\sin(2\pi\cdot2x).$$

### B-splines basis

A b-spline basis $\{B_{i,p}(x)\}_{i=-p}^{k}$ 
on the interval $[t_0,t_{k+1}]$
is defined as
$$B_{i,0}(x) = \left\{
    \begin{aligned}
        &I_{(t_i,t_{i+1}]}(x), & i = 0,1,\dots,k\\
        &0, &i<0\ or\ i>k
    \end{aligned}
\right.$$
$$B_{i,r}(x) = \frac{x - t_{i}}{t_{i+r}-t_{i}} B_{i,r-1}(x) + \frac{t_{i+r+1} - x}
{t_{i+r+1} - t_{i+1}}B_{i+1,r-1}(x)$$
For all the discontinuity points of $B_{i,r}$ ($r>0$) in the interval $(t_0,t_k)$, 
let the value equals its limit, which means
$$B_{i,r}(x) = \lim_{t\to x} B_{i,r}(t).$$
Slot ***Boundary.knots*** is boundary of the domain of the splines (start and end), 
which is $t_0$ and $t_{k+1}$. 
Default is $[0,1]$. 
Slot ***knots*** represents the knots of the splines, which is $(t_1,\dots,t_k)$, 
equally spaced sequence is chosen by the function automatically with equal space 
($t_j = t_0 + j\cdot\frac{t_{k+1}-t_0}{k+1}$)
when not assigned. 
Slot ***intercept*** is whether an intercept is included in the basis, 
default value is TRUE, and must be TRUE.
Slot ***df*** is the degree of freedom of the basis, which is the number of the splines, 
equal to $p+k+1$. 
By default $k =0$ and $\text{df} = p+1$.
Slot ***degree*** is the degree of the splines, 
which is the degree of piecewise polynomials $p$, default value is 3. See degree in bs.


#### S4 class ***bspline_basis***

In MECfda package, we have a s4 class, ***bspline_basis*** that represents
a b-spline basis $\{B_{i,p}(x)\}_{i=-p}^{k}$ on the interval $[t_0,t_{k+1}]$. 
And we a s4 class, ***bspline_series*** that represents
the summation $\sum_{i=0}^{k}b_i B_{i,p}(x)$. 
Slot ***coef*** contains the coefficients of the b-splines, $b_i$. ($i = 0,\dots,k$)
Slot ***bspline_basis*** is a ***bspline_basis*** object, represents the b-splines basis used, 
$\{B_{i,p}(x)\}_{i=-p}^{k}$.


Method ***plot*** for class ***bspline_basis*** is provided to draw the image of the summation function. 
Method ***bsplineSeries2fun*** is provided to compute the value of the summation function. 
Argument ***object***	should be an object of ***bspline_series*** class.
Argument ***x*** is the value of independent variable $x$. 

```{r c2}
bsb = bspline_basis(
  Boundary.knots = c(0,24),
  df             = 7,
  degree         = 3
)
bss = bspline_series(
  coef = c(2,1,3/4,2/3,7/8,5/2,19/10),
  bspline_basis = bsb
)
plot(bss)
bsplineSeries2fun(bss,seq(0,24,0.5))
```

The object ***bsb*** represents 
$\{B_{i,3}(x)\}_{i=-3}^{0}$, 
and object ***bss*** represents the 
$$2B_{i,-3}(x)+B_{i,-2}(x)+\frac34B_{i,-1}(x)+\frac23B_{i,0}(x) + \frac78B_{i,1}(x) + 
\frac52B_{i,2}(x) +\frac{19}{10}B_{i,3}(x),$$
where $x\in[t_0,t_4]$ and $t_0=0$, $t_k = t_{k-1}+6$ ,$k=1,2,3,4$. 

#### basis2fun

A generic function ***basis2fun*** is provide for 
class ***Fourier_series*** and ***bspline_series***. 
When applied to ***Fourier_series*** object, it is equivalent to method ***FourierSeries2fun***.
When applied to ***bspline_series*** object, it is equivalent to method ***bsplineSeries2fun***.

```{r basis2fun}
basis2fun(fsc,seq(0,1,0.05))
basis2fun(bss,seq(0,24,0.5))
```

### Eigenfunction basis

Suppose $K(s,t)\in L^2(\Omega\times \Omega)$,
$f(t)\in L^2(\Omega)$. 
Then $K$ induces an linear operator $\mathcal{K}$ by 
$$(\mathcal{K}f)(x) = \int_{\Omega} K(t,x)f(t)dt$$
If $\xi(\cdot)\in L^2(\Omega)$ s.t. 
$$\mathcal{K}\xi = \lambda \xi$$
where $\lambda\in C$,
then we call $\xi$ a eigenfunction/eigenvector of 
$\mathcal{K}$ and $\lambda$ a eigenvalue associated with $\xi$. 

All the eigenfunctions of $\mathcal{K}$ make a basis of $L^2(\Omega)$. 
We call the basis induced by 
$$K(s,t)=\text{Cov}(X(t),X(s))$$
a functional principal component (FPCA) basis,
where $\{X(t),t\in\Omega\}$ is a stochastic process.

### Basis expansion methods for ***functional_variable*** class

The pakcage MECfda provide method ***fourier_basis_expansion*** and ***bspline_basis_expansion*** for
class ***functional_variable*** to do basis expansion using Fourier basis and b-spline basis respectively

```{r be}
data(MECfda.data.sim.0.0)
fv = MECfda.data.sim.0.0$FC[[1]]
BE.fs = fourier_basis_expansion(fv,5L)
BE.bs = bspline_basis_expansion(fv,5L,3L)
```

## Numerical Computation of Integrals

We use
$$\frac{1}{|T|}\sum_{t\in T} \rho_{k}(t) X_{i}(t)$$
to compute the integral
$$\int_{\Omega} \rho_{k}(t) X_{i}(t) dt$$
where $T$ is the measurement (time) points of $X_{i}(t)$, 
$|T|$ represents the cardinal number of $T$. 

# Scalar-on-function Linear Regression in MECfda

## fcRegression

```{r shili1, eval = FALSE}
fcRegression(Y, FC, Z, formula.Z, family = gaussian(link = "identity"),
             basis.type = c("Fourier", "Bspline"), basis.order = 6L, 
             bs_degree = 3)
```

The MECfda package provides a function ***fcRegression*** to fit 
generalized linear mixed effect models,
including ordinary linear model, 
generalized linear model with fixed and random effect,
using basis expansion to discretize the function-valued covariates. 
The function ***fcRegression*** can solve a linear model in the following form:
$$g(E(Y_i|X_i,Z_i)) = \sum_{l=1}^{L} 
\int_{\Omega_l} \beta_l(t) X_{li}(t) dt + (1,Z_i^T)\gamma.$$
The funciton can allow one or multiple function-valued covariate(s) as fixed effect(s),
and zero, one, or multiple scalar-valued covariate(s) as fixed or random effect(s).
Response variable, function-valued covariate(s), and scalar-valued covariate(s) 
are input separately as three different arguements, ***Y***, ***FC***, and ***Z*** respectively. 
The format of the input data can be very flexible. 
For response variable, the input format can be an atomic vector, 
a one-column matrix or data frame. 
Recommended form is a one-column data frame or matrix with column name,
because in this case, the name of response variable is specified. 
For input data of function-valued covariate(s), 
a ***functional_variable*** object or a matrix or a data frame or a list of these object(s)
can be accepted.
When one ***functional_variable*** object or a matrix or a data frame is input as argument ***FC***, 
there is only one function-valued covariate in the model. 
When list of these object(s) is input as argument ***FC***, 
the model can have multiple function-valued covariates,
each element of the list is correspondent to a function-valued covariate. 
For input data of scalar-valued covariates, 
a matrix, data frame, atomic vector, NULL or, not input can be accepted. 
When not assign input value for argument ***Z***, 
there is no scalar-valued covariate in the model and argument ***formula.Z*** 
should also be NULL or not input. 
When an atomic vector is input as argument ***Z***, 
there is only one scalar-valued in the model. 
And in this case, the name of the scalar-valued covariate is not specified. 
So even if there is only one scalar-valued covariate, 
a matrix or data frame with colname is recommended to be input as argument ***Z***. 
Argument formula.Z is used to specify which part of the argument ***Z*** is used
and how to treat the scalar-valued covariates, 
whether to use them as fixed effects or random effects. 
Argument ***family*** can specify the distribution type of response variable and link function 
to be used in the regression. 
Argument ***basis.type*** indicate the type of basis function to be used in basis expansion process.
Available options are 'Fourier' and 'Bspline', 
represent Fourier basis and b-spline basis respectively.
Argument ***basis.order*** indicates number of the function basis to be used. 
When using Fourier basis $\frac{1}{2},\sin k t, \cos k t, k = 1,\dots,p_f$, 
***basis.order*** is the number $p_f$.
When using b-splines basis $\{B_{i,p}(x)\}_{i=-p}^{k}$,
***basis.order*** is the number of splines, equal to $k+p+1$.
Argument ***bs_degree*** specify the degree of the piecewise polynomials of b-spline basis function
if use b-splines basis.
This argument is need only when using b-spline basis. 

The function ***fcRegression*** returns an object of s3 class ***fcRegression***. 
It is a list that contains following elements. 

1. regression_result: result of the regression.
2. FC.BasisCoefficient: a list of Fourier_series or bspline_series object(s), 
represents the functional linear coefficient(s) of the functional covariates.
3. function.basis.type: type of funtion basis used.
4. basis.order: same as in the arguemnets.
5. data: original data.
6. bs_degree: degree of the splines, returned only if b-splines basis is used.

We can use method ***predict*** to get predicted value from the model
and use method ***fc.beta*** to get the value of function-valued linear coefficient 
parameters $\beta_l(t)$. 

```{r fcglmm}
data(MECfda.data.sim.0.0)
res = fcRegression(FC = MECfda.data.sim.0.0$FC, 
                   Y=MECfda.data.sim.0.0$Y, 
                   Z=MECfda.data.sim.0.0$Z,
                   family = gaussian(link = "identity"),
                   basis.order = 5, basis.type = c('Bspline'),
                   formula.Z = ~ Z_1 + (1|Z_2))
t = (0:100)/100
plot(x = t, y = fc.beta(res,1,t), ylab = expression(beta[1](t)))
plot(x = t, y = fc.beta(res,2,t), ylab = expression(beta[2](t)))
data(MECfda.data.sim.1.0)
predict(object = res, newData.FC = MECfda.data.sim.1.0$FC,
        newData.Z = MECfda.data.sim.1.0$Z)
```

## fcQR

```{r shili2, eval = FALSE}
fcQR(Y, FC, Z, formula.Z, tau = 0.5, basis.type = c("Fourier", "Bspline"),
     basis.order = 6L, bs_degree = 3)
```

The MECfda package provides a function ***fcQR*** to fit 
quantile linear regression models.
The method to deal with function-valued covariates is also
discretization using basis expansion. 
The function ***fcQR*** can solve a linear model in the following form:
$$Q_{Y_i|X_i,Z_i}(\tau) = \sum_{l=1}^L\int_{\Omega_l} \beta_l(\tau,t) X_{li}(t) dt +  (1,Z_i^T)\gamma.$$
The funciton can allow one or multiple function-valued covariate(s),
and zero, one, or multiple scalar-valued covariate(s).
The way and rules to input the data is exact the same as function ***fcRegression***.
How to treat the scalar-valued covariates is also specified by 
the argument ***formula.Z***, similar to in function ***fcRegression***. 
The only difference is that there is no random effect in quantile linear regression model. 
The quantile $\tau$ is specified by the argument ***tau***. 
The type and parameters of the basis function are also specified by 
argument ***basis.type***, ***basis.order***, and ***bs_degree*** as in function ***fcRegression***. 

The function ***fcQR*** returns an object of s3 class ***fcQR***. 
It is a list that contains contains the following elements.

1. regression_result: Result of the regression.
2. FC.BasisCoefficient: A list of Fourier_series or bspline_series object(s), 
represents the functional linear coefficient(s) of the functional covariates.
3. function.basis.type: Type of funtion basis used.
4. basis.order: Same as in the arguemnets.
5. data: Original data.
6. bs_degree: Degree of the splines, returned only if b-splines basis is used.

We can use method ***predict*** to get predicted value from the model
and use method ***fc.beta*** to get the value of function-valued linear coefficient 
parameters $\beta_l(t)$. 

```{r fcqr}
data(MECfda.data.sim.0.0)
res = fcQR(FC = MECfda.data.sim.0.0$FC, 
           Y=MECfda.data.sim.0.0$Y, 
           Z=MECfda.data.sim.0.0$Z,
           tau = 0.5,
           basis.order = 5, basis.type = c('Bspline'),
           formula.Z = ~ .)
t = (0:100)/100
plot(x = t, y = fc.beta(res,1,t), ylab = expression(beta[1](t)))
plot(x = t, y = fc.beta(res,2,t), ylab = expression(beta[2](t)))
data(MECfda.data.sim.1.0)
predict(object = res, newData.FC = MECfda.data.sim.1.0$FC,
        newData.Z = MECfda.data.sim.1.0$Z)
```

# Measurement Error Models and Bias Correction Estimation Methods

Data in real world often have measurement error, 
especially for function-valued data. 
And measurement error in data set may lead to bias in estimation. 
Package MECfda also provides functions of bias correction estimation method
for some certain linear regression models with measurement error. 

### ME.fcRegression_MEM

```{r shili3, eval = FALSE}
ME.fcRegression_MEM(
  data.Y,
  data.W,
  data.Z,
  method = c("UP_MEM", "MP_MEM", "average"),
  t_interval = c(0, 1),
  t_points = NULL,
  d = 3,
  family.W = c("gaussian", "poisson"),
  family.Y = "gaussian",
  formula.Z,
  basis.type = c("Fourier", "Bspline"),
  basis.order = NULL,
  bs_degree = 3,
  smooth = FALSE,
  silent = TRUE
)
```

Wearable monitoring devices permit the continuous monitoring of biological processes, such as blood glucose metabolism, and behavior, such as sleep quality and physical activity.  The continuous monitoring often occurs in epochs of 60 seconds over multiple days resulting in high dimensional multi-level longitudinal curves that are best described and analyzed as multi-level functional data.  While researchers have previously addressed measurement error in scalar covariates prone to error, less work has been done on correcting measurement error in multi-level high dimensional curves prone to heteroscedastic measurement errors.  Therefore, Luan et. al.  proposed mixed effects-based methods for bias correction due to measurement error in multi-level functional data from the exponential family of distributions and prone to complex heteroscedastic measurement error.

They first develop mixed effects-based methods to adjust for biases due to the presence of measurement error in multi-level generalized functional regression models.  To do this, they assume the distributions of the functional covariates prone to measurement errors belong in the exponential family.  This assumption allows for a more general specification of the distributions of error-prone functional covariates compared to current approaches that often entail normality assumptions for these observed measures.  By this, they allow the true measurement and observed measurement prone to measurement error to have a non-linear association.  Second, they treat the random errors in the observed measures as complex heteroscedastic errors from the Gaussian distribution with covariance error functions.  Third, our methods can be used to evaluate relationships between multi-level functional covariates with complex measurement error structures and scalar outcomes with distributions in the exponential family.  Fourth, they treat the functional covariate as an observed measure for the true functional unobserved latent covariate.  Additionally, our proposed methods employ a point-wise method to fit the multi-level functional mixed effects-based approach, avoiding the need for computing complex and intractable integrals which would be required in traditional approaches to reducing biases due measurement error in multi-level functional data.
[@luan2023scalable]

Their statistical model is as follow:
\begin{align*}
  &g(E(Y_i|X_i,Z_i)) = \int_{\Omega} \beta(t) X_{i}(t) dt + (1,Z_i^T)\gamma\\
  &h(E(W_{ij}(t)|X_i(t))) = X_i(t)\\
  &X_i(t) = \mu_x(t) + \varepsilon_{xi}(t)
\end{align*}
where
response variable $Y_i$ and scalar-valued covariates $Z_i$ are measured without error, 
function-valued covariate $X_i(t)$ is repeatedly measured with error as $W_{ij}(t)$. 
And they have additional assumption:

1. $Y_i|X_i,Z_i\sim EF(\cdot)$, $EF$ refers to an exponential family distribution. 
2. $g(\cdot)$ and $h(\cdot)$ are known monotone, twice continuously differentiable functions.
3. $Cov\{X_i(t),W_{ij}(t)\} \neq 0$, 
4. $W_{ij}(t)|X_i(t)\sim EF(\cdot)$
5. $f_{Y_i|W_{ij}(t),X_i(t)}(\cdot) = f_{Y_i|X_i(t)}(\cdot)$, $f$ refers to PDF. 
6. $X_i(t)\sim GP\{\mu_x(t),\Sigma_{xx}\}$, $GP$ refers to Gaussian process. 

They proposed a mixed effects model-based estimation method 
to correct the bias caused by the measurement error in the functional covariate. 
It allows us to investigate the nonlinear measurement error model, 
where the relationship between the true and observed measurements is not constrained to be linear, 
and the distribution assumption on the observed measurement is relaxed to encompass 
the exponential family rather than being limited to the Gaussian distribution. 

The mixed-effects model-based (MEM) approach is a two stage method that employs 
functional mixed-effects models. 
The first stage of the MEM approach is 
to approximate the true measure $X_i(t)$ with the repeated observed measurement $W_{ij}(t)$ 
using a functional mixed-effects model. 
It is mainly based on the assumption that 
$h[E\{W_{ij}(t)|X_i(t)\}] = X_i(t)$ and $X_i(t) = \mu_x(t) + \varepsilon_{xi}(t)$. 
That is, the random intercept in the functional mixed-effects model 
with one fixed-intercept and one random intercept is assumed to to be the subject-wise 
deviation of $X_i(t)$ from the mean process $\mu_x(t)$ while the fixed intercept 
is assumed to represent $\mu_x(t)$. The second stage involves replacing $X_i(t)$ 
with the resulting approximation of $X_i(t)$ from the first stage in the regression model. 
The MEM approach employs point-wise (UP_MEM) and multi-point-wise (MP_MEM) 
estimation procedures to avoid potential computational complexities caused 
by analyses of multi-level functional data and 
computations of potentially intractable and complex integrals. 

Package MECfda provide a function ***ME.fcRegression_MEM*** 
to apply their bias correction estimation method. 
Response variable, function-valued covariate(s), and scalar-valued covariate(s) 
are input separately as three different arguments. 
Argument ***data.Y***	is the response variable. 
Input can be an atomic vector, a one-column matrix or data frame, 
recommended form is a one-column data frame with column name. 
Argument ***data.W*** is the data of $W$, the measurement of $X$, in the statistical model. 
The input should be a 3-dimensional array. 
Each row represents a subject. 
Each column represent a measurement (time) point. 
Each layer represents an observation.
Argument ***data.Z*** is the data of scalar covariate(s), 
It can be not input or NULL (when there's no scalar covariate), 
an atomic vector (when only one scalar covariate), 
a matrix or data frame, 
recommended form is a data frame with column name(s). 
Argument ***method***	 specifies method to construct the substitution $X$. 
Available options: 'UP_MEM', 'MP_MEM', 'average'. 
Argument ***t_interval***	specifies the domain of the function-valued covariate. 
It should be a 2-element vector, represents an interval. 
Default is c(0,1), represent interval $[0,1]$.
Argument ***t_points***	is the sequence of the measurement (time) points, 
default is NULL.
Argument d is the number of time points involved for MP_MEM 
(default and miniumn is 3).
Argument ***family.W***	is the distribution of $W$ given $X$. 
Available options are ***gaussian*** and ***poisson***. 
Argument ***family.Y***	is a description of the error distribution 
and link function to be used in the model. See stats::family. 
Argument ***formula.Z*** is used to specify which part of the argument ***Z*** is used
and how to treat the scalar-valued covariates, 
whether to use them as fixed effects or random effects. 
Argument ***basis.type*** indicate the type of basis function to be used in basis expansion process.
Available options are 'Fourier' and 'Bspline', 
represent Fourier basis and b-spline basis respectively.
Argument ***basis.order*** indicates number of the function basis to be used. 
When using Fourier basis $\frac{1}{2},\sin k t, \cos k t, k = 1,\dots,p_f$, 
***basis.order*** is the number $p_f$.
When using b-splines basis $\{B_{i,p}(x)\}_{i=-p}^{k}$,
***basis.order*** is the number of splines, equal to $k+p+1$.
Argument ***bs_degree*** specify the degree of the piecewise polynomials of b-spline basis function
if use b-splines basis.
This argument is need only when using b-spline basis. 
Argument ***smooth***	specifies whether to smooth the substitution of $X$, 
default is FALSE.
Argument ***silent***	specifies whether not to show the state of the running of the function, 
default is TRUE.

And the function ME.fcRegression_MEM returns a fcRegression object.

```{r MEM, eval = FALSE}
data(MECfda.data.sim.0.1)
res = ME.fcRegression_MEM(data.Y = MECfda.data.sim.0.1$Y,
                          data.W = MECfda.data.sim.0.1$W,
                          data.Z = MECfda.data.sim.0.1$Z,
                          method = 'UP_MEM',
                          family.W = "gaussian",
                          basis.type = 'Bspline')
```

### ME.fcQR_IV.SIMEX

```{r shili4, eval = FALSE}
ME.fcQR_IV.SIMEX(
  data.Y,
  data.W,
  data.Z,
  data.M,
  tau = 0.5,
  t_interval = c(0, 1),
  t_points = NULL,
  formula.Z,
  basis.type = c("Fourier", "Bspline"),
  basis.order = NULL,
  bs_degree = 3
)
```

Health is one of the major concerns people have in mind, and as technology advances, wearable devices have become the mainstream method of monitoring and evaluating people’s physical activity levels. Despite personal preferences in brands and feature design, the accuracy of the data presented is what makes the device a great product. These functional data collected from devices are generally considered more accurate and subjective compared to other objective methods like questionnaires and self-reports. Since physical activities level is not directly observable, algorithms are responsible for generating corresponding summaries on different activities using complex data containing steps, heart rate, etc.  However, the results could differ depending on which device is used.  And aside from variation in hardware, data collected could also vary by the combinations between how the device is worn and the activity of interest. One might argue that the accuracy of today’s devices is good enough for consumers to monitor their workout level, but with more precise data, functions such as detecting irregular heart rhythms or radiation exposures could improve the health of the general public and contribute to elevating society well-being. 

Quantile regression is a tool developed upon the need for modeling complex relationships between a set of covariates and quantiles of an outcome. In obesity studies, the effects of interventions or covariates on body mass index (BMI) are mostly estimated using ordinary least square methods. However, the use of mean regression approaches could not address well the questions for people whose BMI falls in the upper quantile of the distribution. Comparing to traditional linear regression, quantile regression makes no assumption on the distribution of residuals and is robust to outlying observations. 

<!-- Thus, we would like to propose the linear quantile regression function with measurement error correction on functional data and demonstrate its usefulness in the National Health and Nutrition Examination Survey (NHANES) dataset with a focus on evaluating the association between physical activities and obesity.  -->

Tekwe et. al. 
proposed a simulation extrapolation (SIMEX) estimation method 
to correct the bias in scalar-on-function quantile linear regression 
due to measurement error using instrumental variable. 
And they demonstrated its usefulness in the National Health and Nutrition Examination Survey (NHANES) dataset with a focus on evaluating the association between physical activities and obesity.
[@tekwe2022estimation]
Their statistical model is as follow:
\begin{align*}
  &Q_{Y_i|X_i,Z_i}(\tau) = \int_{\Omega} \beta(\tau,t) X_{i}(t) dt +  (1,Z_i^T)\gamma(\tau)\\
  &W_i(t) = X_i(t) + U_i(t)\\
  &M_i(t) = \delta(t) X_i(t) + \eta_i(t)
\end{align*}
where
response variable $Y_i$ and scalar-valued covariates $Z_i$ are measured without error, 
function-valued covariate $X_i(t)$ is measured with error as $W_i(t)$,
and $M_i(t)$ is an measured instrumental variable. 
And they have additional assumption:

1. $Cov\{X_i(t),U_i(s)\} = 0$, 
2. $Cov\{M_i(t),U_i(s)\} = 0$, 
3. $E(W_{i}(t)|X_i(t)) = X_i(t)$
4. $U_i(t)\sim GP\{\mathcal{0},\Sigma_{uu}\}$, $GP$ refers to Gaussian process. 

for $\forall t,s\in[0,1]$ and $i = 1,\dots,n$. 

Their bias correction estimation method 
performs a two-stage strategy to correct the measurement error of a function-valued covariate 
and then fit a linear quantile regression model. 
In the first stage, 
an instrumental variable is used to estimate the covariance matrix associated with the measurement error. 
In the second stage, 
simulation extrapolation (SIMEX) is used to correct for measurement error in the function-valued covariate.

Package MECfda provide a function ***ME.fcQR_IV.SIMEX*** 
to apply their bias correction estimation method. 
Argument ***data.Y***	is the response variable. 
Input can be an atomic vector, a one-column matrix or data frame, 
recommended form is a one-column data frame with column name. 
Argument ***data.W*** is the data of $W$, the measurement of $X$, in the statistical model. 
The input should be a dataframe or matrix. 
Each row represents a subject. 
Each column represent a measurement (time) point. 
Argument ***data.Z*** is the data of scalar covariate(s), 
It can be not input or NULL (when there's no scalar covariate), 
an atomic vector (when only one scalar covariate), 
a matrix or data frame, 
recommended form is a data frame with column name(s). 
Argument ***data.M*** is the data of $M$,
the instrumental variable. 
Input should be a dataframe or matrix.
Each row represents a subject. 
Each column represent a measurement (time) point.
Argument ***tau*** is the quantile $\tau\in(0,1)$, default is 0.5.
Argument ***t_interval***	specifies the domain of the function-valued covariate. 
It should be a 2-element vector, represents an interval. 
Default is c(0,1), represent interval $[0,1]$.
Argument ***t_points***	is the sequence of the measurement (time) points, 
default is NULL.
Argument ***formula.Z*** is used to specify which part of the argument ***Z*** is used
and how to treat the scalar-valued covariates. 
Argument ***basis.type*** indicate the type of basis function to be used in basis expansion process.
Available options are 'Fourier' and 'Bspline', 
represent Fourier basis and b-spline basis respectively.
Argument ***basis.order*** indicates number of the function basis to be used. 
When using Fourier basis $\frac{1}{2},\sin k t, \cos k t, k = 1,\dots,p_f$, 
***basis.order*** is the number $p_f$.
When using b-splines basis $\{B_{i,p}(x)\}_{i=-p}^{k}$,
***basis.order*** is the number of splines, equal to $k+p+1$.
Argument ***bs_degree*** specify the degree of the piecewise polynomials of b-spline basis function
if use b-splines basis.
This argument is need only when using b-spline basis. 

Function ***ME.fcQR_IV.SIMEX*** returns a ME.fcQR_IV.SIMEX class object. 
It is a list that contains the following elements.

1. coef.X: A Fourier_series or bspline_series object, represents the functional coefficient parameter of the functional covariate.
2. coef.Z: The estimate of the linear coefficients of the scalar covariates.
3. coef.all: Original estimate of linear coefficients.
4. function.basis.type:	Type of funtion basis used.
5. basis.order:	Same as in the input arguements.
6. t_interval: A 2-element vector, represents an interval, means the domain of the functional covariate.
7. t_points: Sequence of the measurement (time) points.
8. formula: Regression model.
9. formula.Z:	formula object contains only the scalar covariate(s).
10. zlevels: levels of the non-continuous scalar covariate(s).

```{r iv.simex, eval = FALSE}
rm(list = ls())
data(MECfda.data.sim.0.2)
res = ME.fcQR_IV.SIMEX(data.Y = MECfda.data.sim.0.2$Y,
                       data.W = MECfda.data.sim.0.2$W,
                       data.Z = MECfda.data.sim.0.2$Z,
                       data.M = MECfda.data.sim.0.2$M,
                       tau = 0.5,
                       basis.type = 'Bspline')
```

### ME.fcQR_CLS

```{r shili5, eval = FALSE}
ME.fcQR_CLS(
  data.Y,
  data.W,
  data.Z,
  tau = 0.5,
  t_interval = c(0, 1),
  t_points = NULL,
  grid_k,
  grid_h,
  degree = 45,
  observed_X = NULL
)
```

Zhang et. al. 
proposed a corrected loss score estimation method for scalar-on-function
quantile linear regression to correct the bias 
due to measurement error. 
[@zhang2023partially]
Their statistical model is as follow:
\begin{align*}
  &Q_{Y_i|X_i,Z_i}(\tau) = \int_{\Omega} \beta(\tau,t) X_{i}(t) dt +  (1,Z_i^T)\gamma(\tau)\\
  &W_i(t) = X_i(t) + U_i(t)
\end{align*}
where
response variable $Y_i$ and scalar-valued covariates $Z_i$ are measured without error, 
function-valued covariate $X_i(t)$ is measured with error as $W_i(t)$. 

1. $E[U_i(t)]=0$.
2. $Cov\{U_i(t),U_i(s)\} = \Sigma_U(s,t)$, where $\Sigma_U(s,t)$ is unknown. 
3. $U_i(t)$ are i.i.d for different $i$. 

Zhang et al. proposed a new corrected loss function 
for a partially functional linear quantile model with functional measurement error in this manuscript. 
They established a corrected quantile objective function of the observed measurement 
that is an unbiased estimator of the quantile objective function that would be obtained 
if the true measurements were available. The estimators of the regression parameters 
are obtained by optimizing the resulting corrected loss function. 
The resulting estimator of the regression parameters is shown to be consistent.

Package MECfda provide a function ***ME.fcQR_CLS*** 
to apply their bias correction estimation method. 
Argument ***data.Y***	is the response variable. 
Input can be an atomic vector, a one-column matrix or data frame, 
recommended form is a one-column data frame with column name. 
Argument ***data.W*** is the data of $W$, the measurement of $X$, in the statistical model. 
The input should be a 3-dimensional array. 
Each row represents a subject. 
Each column represent a measurement (time) point. 
Each layer represents an observation.
Argument ***data.Z*** is the data of scalar covariate(s), 
It can be not input or NULL (when there's no scalar covariate), 
an atomic vector (when only one scalar covariate), 
a matrix or data frame, 
recommended form is a data frame with column name(s). 
Argument ***tau*** is the quantile $\tau\in(0,1)$, default is 0.5.
Argument ***t_interval***	specifies the domain of the function-valued covariate. 
It should be a 2-element vector, represents an interval. 
Default is c(0,1), represent interval $[0,1]$.
Argument ***t_points***	is the sequence of the measurement (time) points, 
default is NULL.
Argument ***grid_k***	is an atomic vector, of which each element is candidate number of basis.
Argument ***grid_h***	is a non-zero-value atomic vector, of which each element is candidate value of tunning parameter.
Argument ***degree***	is Used in computation for derivative and integral, defult is 45, large enough for most scenario.
Argument ***observed_X***	is for estimating parametric variance. Default is NULL.

The function returns a ME.fcQR_CLS class object. It is a list that contains the following elements.

1. estimated_beta_hat: Estimated coefficients from corrected loss function (including functional part)
2. estimated_beta_t: Estimated functional curve
3. SE_est: Estimated parametric variance. Returned only if observed_X is not NULL.
4. estimated_Xbasis: The basis matrix we used
5. res_naive: results of naive method

```{r cls, eval = FALSE}
rm(list = ls())
data(MECfda.data.sim.0.1)
res = ME.fcQR_CLS(data.Y = MECfda.data.sim.0.1$Y,
                  data.W = MECfda.data.sim.0.1$W,
                  data.Z = MECfda.data.sim.0.1$Z,
                  tau = 0.5,
                  grid_k = 4:7,
                  grid_h = 1:2)
```

### ME.fcLR_IV

```{r shili6, eval = FALSE}
ME.fcLR_IV(
  data.Y,
  data.W,
  data.M,
  t_interval = c(0, 1),
  t_points = NULL,
  CI.bootstrap = F
)
```

Tekwe et. al. 
proposed a bias correction estimation method for scalar-on-function
linear regression model with measurement error using instrumental variable. 
[@tekwe2019instrumental]
Their statistical model is as follow:
\begin{align*}
  &Y_i = \int_0^1 \beta(t)X_i(t)dt + \varepsilon_i\\
  &W_i(t) = X_i(t) + U_i(t)\\
  &M_i(t) = \delta X_i(t) + \eta_i(t)
\end{align*}
where 
response variable $Y_i$ and are measured without error, 
function-valued covariate $X_i(t)$ is measured with error as $W_i(t)$,
and $M_i(t)$ is an measured instrumental variable. 
And they have additional assumption:

1. $E\varepsilon_i(t) = 0$,
2. $EU_i(t) = 0$,
3. $E\eta_i(t) = 0$,
4. $Cov\{X_i(t),\varepsilon_i\} = 0$, 
5. $Cov\{M_i(t),\varepsilon_i\} = 0$,
6. $Cov\{M_i(t),U_i(s)\} = 0$, 

for $\forall t,s\in[0,1]$ and $i = 1,\dots,n$. 

Package MECfda provide a function ***ME.fcLR_IV*** 
to apply their bias correction estimation method. 
Argument ***data.Y***	is the response variable. 
Input can be an atomic vector, a one-column matrix or data frame, 
recommended form is a one-column data frame with column name. 
Argument ***data.W*** is the data of $W$, the measurement of $X$, in the statistical model. 
The input should be a dataframe or matrix. 
Each row represents a subject. 
Each column represent a measurement (time) point. 
Argument ***data.M*** is the data of $M$,
the instrumental variable. 
Input should be a dataframe or matrix.
Each row represents a subject. 
Each column represent a measurement (time) point.
Argument ***t_interval***	specifies the domain of the function-valued covariate. 
It should be a 2-element vector, represents an interval. 
Default is c(0,1), represent interval $[0,1]$.
Argument ***t_points***	is the sequence of the measurement (time) points, 
default is NULL.
Argument ***CI.bootstrap***	specifies whether to 
return the confidence using bootstrap method. 
Default is FALSE.

The function returns a ME.fcLR_IV class object. It is a list that contains the following elements.

1. beta_tW: parameter estimates.
2. CI: confidence interval, returned only when CI.bootstrap is TRUE.


```{r lriv, eval = FALSE}
rm(list = ls())
data(MECfda.data.sim.0.3)
res = ME.fcLR_IV(data.Y = MECfda.data.sim.0.3$Y,
                 data.W = MECfda.data.sim.0.3$W,
                 data.M = MECfda.data.sim.0.3$M)
```

# References


























