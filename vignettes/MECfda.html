<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Introduction to MECfda Package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>

<style type="text/css">
p.abstract{
text-align: center;
font-weight: bold;
}
div.abstract{
margin: auto;
width: 90%;
}
</style>


<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to MECfda Package</h1>
<h4 class="author">Heyang Ji</h4>
<h4 class="author">Yuanyuan Luan</h4>
<h4 class="author">Xiwei Chen</h4>
<div class="abstract">
<p class="abstract">Abstract</p>
Package MECfda provide functions that sovle a variaty of
scalar-on-function linear regression models and estimation methods that
correct the bias due to measurement error in such models.
</div>



<!-- output: pdf_document -->
<!-- output: rmarkdown::html_vignette -->
<!-- output: html_document -->
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Scalar-on-function linear regression is an important problem in
functional data analysis. Our aim is to develop an R package that can
solve all kinds of scalar-on-function linear regression models and
correct the bias due to measurement error in scalar-on-function linear
regression models.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(MECfda)</span></code></pre></div>
</div>
<div id="scalar-on-function-linear-regression-models" class="section level1">
<h1>Scalar-on-function Linear Regression Models</h1>
<p>The generic form of scalar-on-function linear regression model is
<span class="math display">\[T(F_{Y_i|X_i,Z_i}) =  \sum_{l=1}^{L}
\int_{\Omega_l} \beta_l(t) X_{li}(t) dt + (1,Z_i^T)\gamma\]</span> where
<span class="math inline">\(Y_i\)</span> represents the scalar-valued
response variable, <span class="math inline">\(X_{li}(t)\)</span>
represents the function-valued covariates (<span class="math inline">\(l=1,\dots,L\)</span>), <span class="math inline">\(\beta_l\)</span> and <span class="math inline">\(X_{li}\)</span> (<span class="math inline">\(t\in\Omega_l\)</span>) are in <span class="math inline">\(L^2(\Omega_l)\)</span>, <span class="math inline">\(Z_i = (Z_{1i},\dots,Z_{qi})^T\)</span> represents
the scalar valued covariates, <span class="math inline">\(\gamma =
(\gamma_0,\gamma_1,\dots,\gamma_q)^T\)</span>, <span class="math inline">\(F_{Y_i|X_i,Z_i}\)</span> represents the CDF of the
<span class="math inline">\(Y_i\)</span> given <span class="math inline">\(X_i\)</span> and <span class="math inline">\(Z_i\)</span>, <span class="math inline">\(T(\cdot)\)</span> is a statistical functional.</p>
<p>In ordinary scalar-on-function generalized linear (mixed) models,
<span class="math display">\[T(F_{Y_i|X_i,Z_i}) =
g\left\{\int_\mathbb{R}ydF_{Y_i|X_i,Z_i}(y)\right\} =
g(E[Y_i|X_i,Z_i]),\]</span> where <span class="math inline">\(g(\cdot)\)</span> is a link function.</p>
<p>In scalar-on-function quantile linear regression models, <span class="math display">\[T(F_{Y_i|X_i,Z_i}) = Q_{Y_i|X_i,Z_i}(\tau) =
F_{Y_i|X_i,Z_i}^{-1}(\tau),\]</span> where <span class="math inline">\(F_{Y_i|X_i,Z_i}^{-1}(\cdot)\)</span> is the
inverse of <span class="math inline">\(F_{Y_i|X_i,Z_i}(\cdot)\)</span>,
<span class="math inline">\(\tau\in(0,1)\)</span>.</p>
<div id="functional-data" class="section level2">
<h2>Functional Data</h2>
<p>Function-valued variables (functional variables) are usually recorded
by the value of the function(s) at some certain (time) points in its
domain. The data of a function variable is often in a form of a matrix
<span class="math inline">\((x_{ij})_{n\times m}\)</span>, where <span class="math inline">\(x_{ij} = f_i(t_j)\)</span>, represents the value
of <span class="math inline">\(f_i(t_j)\)</span>, each row represent an
observation (subject), each column is corresponding to a measurement
(time) point.</p>
<div id="s4-class-functional_variable" class="section level4">
<h4>S4 class “functional_variable”</h4>
<p>In MECfda package, we have a s4 class, “functional_variable” that
represents the data of a functional variable in this matrix form. The
class has a slot “X” for matrix <span class="math inline">\((x_{ij})_{n\times m}\)</span>, and slots “t_0” and
“period” for the left end and length of the domain of the functional
variable and slot “t_points” (time) points that the functional variable
is measured. And a method “dim” is provided to return the number of
subject(s) and measurement (time) points of a “functional_variable”
object.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>fv <span class="ot">=</span> <span class="fu">functional_variable</span>(</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  <span class="at">X =</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(<span class="dv">10</span><span class="sc">*</span><span class="dv">24</span>),<span class="dv">10</span>,<span class="dv">24</span>),</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  <span class="at">t_0 =</span> <span class="dv">0</span>,</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  <span class="at">period =</span> <span class="dv">1</span>,</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  <span class="at">t_points =</span> (<span class="dv">0</span><span class="sc">:</span><span class="dv">9</span>)<span class="sc">/</span><span class="dv">10</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>)</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="fu">dim</span>(fv)</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">#&gt;     subject time_points </span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co">#&gt;          10          24</span></span></code></pre></div>
</div>
</div>
<div id="basis-expansion" class="section level2">
<h2>Basis Expansion</h2>
<p><span class="math inline">\(\{\rho_{k}\}_{k=1}^\infty\)</span> is a
basis sequence of <span class="math inline">\(L^2(\Omega)\)</span>. For
an arbitrary function-valued parameter <span class="math inline">\(\beta(\cdot)\in L^2(\Omega)\)</span>, there exist
number sequence <span class="math inline">\(\{c_{k}\}_{k=1}^\infty\)</span> s.t. <span class="math display">\[\beta(t) = \sum_{k=1}^\infty
c_{k}\rho_{k}(t)\]</span> and for a function-valued variable <span class="math inline">\(X_i(t)\)</span>, <span class="math display">\[\int_\Omega\beta(t) X_i(t) dt
= \int_\Omega X_i(t) \sum_{k=1}^\infty c_{k}\rho_{k}(t) dt
= \sum_{k=1}^\infty c_{k} \int_\Omega \rho_{k}(t) X_i(t) dt
\]</span> We do a truncation for the infinite basis sequence, then <span class="math display">\[\int_\Omega\beta(t) X_i(t) dt \approx
\sum_{k=1}^K c_{k} \int_\Omega X_i(t) \rho_{k}(t) dt\]</span> For
statistical models with part(s) in the form of <span class="math inline">\(\int_\Omega\beta(t) X_i(t) dt\)</span> we use
<span class="math inline">\(c_{k} \int_\Omega X_i(t) \rho_{k}(t)
dt\)</span> to approximate <span class="math inline">\(\int_\Omega\beta(t) X_i(t) dt\)</span> and treat
<span class="math inline">\(\int_{\Omega} \rho_{k}(t) X_{i}(t)
dt\)</span> as the variables, then the scalar-on-function linear models
is converted to a ordinary scalar-on-scalar linear model, and problem of
estimating <span class="math inline">\(\beta(t)\)</span> is converted to
estimating <span class="math inline">\(c_k\)</span>, <span class="math inline">\(k=1,\dots p\)</span>.</p>
<p>In practice, we may not necessarily use the truncated complete basis
of <span class="math inline">\(L^2\)</span> function space, we can just
use a finite sequence of linearly independent functions as the basis
function.</p>
<p>Performing basis expansion methods to data of functional variable in
matrix form as we mentioned is to compute <span class="math inline">\((b_{ik})_{n\times p}\)</span>, where <span class="math inline">\(b_{ik} = \int_\Omega f(t)\rho_k(t)
dt\)</span>.</p>
<p>Usually the domain <span class="math inline">\(\Omega\)</span> of a
function-valued variable <span class="math inline">\(\{X(t),t\in\Omega\}\)</span> is an interval. And
the commonly used basis sequence types includes Fourier basis, b-splines
basis, and eigen function basis.</p>
<div id="fourier-basis" class="section level3">
<h3>Fourier basis</h3>
<p>The Fourier basis of <span class="math inline">\(L^2([t_0,t_0+T])\)</span> consists of <span class="math display">\[\frac{1}{2},\ \cos(\frac{2\pi}{T}k[x-t_0]),\ \sin
(\frac{2\pi}{T}k[x-t_0])\]</span> where <span class="math inline">\(k =
1,\dots,\infty\)</span>.</p>
<div id="s4-class-fourier_series" class="section level4">
<h4>S4 class “Fourier_series”</h4>
<p>In MECfda package, we have a s4 class, “Fourier_series” that
represents the linear combination of Fourier basis functions <span class="math display">\[\frac{a_0}{2} + \sum_{k=1}^{p_a} a_k
\cos{(\frac{2\pi}{T}k(x-t_0))} +
\sum_{k=1}^{p_b} b_k \sin{(\frac{2\pi}{T}k(x-t_0))},\qquad
x\in[t_0,t_0+T].\]</span> Slot “double_constant” is the value of <span class="math inline">\(a_0\)</span>. Slot “cos” contains the values of
coefficients of <span class="math inline">\(\cos\)</span> waves, <span class="math inline">\(a_k\)</span>. Slot “sin” contains the values of
coefficients of <span class="math inline">\(\sin\)</span> waves, <span class="math inline">\(b_k\)</span>. Slot “k_cos” values of <span class="math inline">\(k\)</span> corresponding to the coefficients of
<span class="math inline">\(\cos\)</span> waves. Slot “k_sin” values of
<span class="math inline">\(k\)</span> corresponding to the coefficients
of <span class="math inline">\(\sin\)</span> waves. Slot “t_0” is the
left end of the domain interval, <span class="math inline">\(t_0\)</span>. Slot “period” is length of the
domain interval, <span class="math inline">\(T\)</span>.</p>
<p>Method “plot” for class “Fourier_series” is provided to draw the
image of the summation function. Method “FourierSeries2fun” is provided
to compute the value of the summation function. Argument “object” should
be an object of “Fourier_series” class. Argument “t” is the value of
independent variable <span class="math inline">\(t\)</span>. Method
“extractCoef” is provided to extract the Fourier coefficients of
“Fourier_series” class object.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>fsc <span class="ot">=</span> <span class="fu">Fourier_series</span>(</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span class="at">double_constant =</span> <span class="dv">3</span>,</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="at">cos =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">2</span><span class="sc">/</span><span class="dv">3</span>),</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="at">sin =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">7</span><span class="sc">/</span><span class="dv">5</span>),</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>  <span class="at">k_cos =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>  <span class="at">k_sin =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>  <span class="at">t_0 =</span> <span class="dv">0</span>,</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>  <span class="at">period =</span> <span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>)</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="fu">plot</span>(fsc)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">FourierSeries2fun</span>(fsc,<span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.05</span>))</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="co">#&gt;  [1]  2.1666667  3.1712610  3.6252757  3.4344848  2.7346112  1.8333333</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">#&gt;  [7]  1.0888125  0.7715265  0.9623175  1.5254623  2.1666667  2.5532270</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt; [13]  2.4497052  1.8164508  0.8324982 -0.1666667 -0.8133005 -0.8465074</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt; [19] -0.2132530  0.9074283  2.1666667</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="fu">extractCoef</span>(fsc)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt; $a_0</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt; 0 </span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt; 3 </span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; $a_k</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt;         1         2 </span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt; 0.0000000 0.6666667 </span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="co">#&gt; $b_k</span></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="co">#&gt;   1   2 </span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a><span class="co">#&gt; 1.0 1.4</span></span></code></pre></div>
<p>The object “fsc” represents the summation <span class="math display">\[\frac32 + \frac23 \cos(2\pi\cdot2x) + \sin(2\pi
x) + \frac75\sin(2\pi\cdot2x).\]</span></p>
</div>
</div>
<div id="b-splines-basis" class="section level3">
<h3>B-splines basis</h3>
<p>A b-spline basis <span class="math inline">\(\{B_{i,p}(x)\}_{i=-p}^{k}\)</span> on the interval
<span class="math inline">\([t_0,t_{k+1}]\)</span> is defined as <span class="math display">\[B_{i,0}(x) = \left\{
    \begin{aligned}
        &amp;I_{(t_i,t_{i+1}]}(x), &amp; i = 0,1,\dots,k\\
        &amp;0, &amp;i&lt;0\ or\ i&gt;k
    \end{aligned}
\right.\]</span> <span class="math display">\[B_{i,r}(x) = \frac{x -
t_{i}}{t_{i+r}-t_{i}} B_{i,r-1}(x) + \frac{t_{i+r+1} - x}
{t_{i+r+1} - t_{i+1}}B_{i+1,r-1}(x)\]</span> For all the discontinuity
points of <span class="math inline">\(B_{i,r}\)</span> (<span class="math inline">\(r&gt;0\)</span>) in the interval <span class="math inline">\((t_0,t_k)\)</span>, let the value equals its
limit, which means <span class="math display">\[B_{i,r}(x) = \lim_{t\to
x} B_{i,r}(t).\]</span> Slot “Boundary.knots” is boundary of the domain
of the splines (start and end), which is <span class="math inline">\(t_0\)</span> and <span class="math inline">\(t_{k+1}\)</span>. Default is <span class="math inline">\([0,1]\)</span>. Slot “knots” represents the knots
of the splines, which is <span class="math inline">\((t_1,\dots,t_k)\)</span>, equally spaced sequence
is chosen by the function automatically with equal space (<span class="math inline">\(t_j = t_0 +
j\cdot\frac{t_{k+1}-t_0}{k+1}\)</span>) when not assigned. Slot
“intercept” is whether an intercept is included in the basis, default
value is TRUE, and must be TRUE. Slot “df” is the degree of freedom of
the basis, which is the number of the splines, equal to <span class="math inline">\(p+k+1\)</span>. By default <span class="math inline">\(k =0\)</span> and <span class="math inline">\(\text{df} = p+1\)</span>. Slot “degree” is the
degree of the splines, which is the degree of piecewise polynomials
<span class="math inline">\(p\)</span>, default value is 3. See degree
in bs.</p>
<div id="s4-class-bspline_basis" class="section level4">
<h4>S4 class “bspline_basis”</h4>
<p>In MECfda package, we have a s4 class, “bspline_basis” that
represents a b-spline basis <span class="math inline">\(\{B_{i,p}(x)\}_{i=-p}^{k}\)</span> on the interval
<span class="math inline">\([t_0,t_{k+1}]\)</span>. And we a s4 class,
“bspline_series” that represents the summation <span class="math inline">\(\sum_{i=0}^{k}b_i B_{i,p}(x)\)</span>. Slot “coef”
contains the coefficients of the b-splines, <span class="math inline">\(b_i\)</span>. (<span class="math inline">\(i =
0,\dots,k\)</span>) Slot “bspline_basis” is a “bspline_basis” object,
represents the b-splines basis used, <span class="math inline">\(\{B_{i,p}(x)\}_{i=-p}^{k}\)</span>.</p>
<p>Method “plot” for class “bspline_basis” is provided to draw the image
of the summation function. Method “bsplineSeries2fun” is provided to
compute the value of the summation function. Argument “object” should be
an object of “bspline_series” class. Argument “x” is the value of
independent variable <span class="math inline">\(x\)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>bsb <span class="ot">=</span> <span class="fu">bspline_basis</span>(</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  <span class="at">Boundary.knots =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">24</span>),</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="at">df             =</span> <span class="dv">7</span>,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="at">degree         =</span> <span class="dv">3</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>bss <span class="ot">=</span> <span class="fu">bspline_series</span>(</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>  <span class="at">coef =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span><span class="sc">/</span><span class="dv">4</span>,<span class="dv">2</span><span class="sc">/</span><span class="dv">3</span>,<span class="dv">7</span><span class="sc">/</span><span class="dv">8</span>,<span class="dv">5</span><span class="sc">/</span><span class="dv">2</span>,<span class="dv">19</span><span class="sc">/</span><span class="dv">10</span>),</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>  <span class="at">bspline_basis =</span> bsb</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>)</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="fu">plot</span>(bss)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">bsplineSeries2fun</span>(bss,<span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">24</span>,<span class="fl">0.5</span>))</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co">#&gt;  [1] 2.0000000 1.7677509 1.5690908 1.4011502 1.2610597 1.1459499 1.0529514</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">#&gt;  [8] 0.9791948 0.9218107 0.8779297 0.8446824 0.8191993 0.7986111 0.7805266</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">#&gt; [15] 0.7644676 0.7504340 0.7384259 0.7284433 0.7204861 0.7145544 0.7106481</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#&gt; [22] 0.7087674 0.7089120 0.7110822 0.7152778 0.7216857 0.7312404 0.7450629</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt; [29] 0.7642747 0.7899969 0.8233507 0.8654574 0.9174383 0.9804145 1.0555073</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; [36] 1.1438380 1.2465278 1.3634786 1.4897151 1.6190430 1.7452675 1.8621942</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; [43] 1.9636285 2.0433759 2.0952418 2.1130317 2.0905511 2.0216053 1.9000000</span></span></code></pre></div>
<p>The object “bsb” represents <span class="math inline">\(\{B_{i,3}(x)\}_{i=-3}^{0}\)</span>, and object
“bss” represents the <span class="math display">\[2B_{i,-3}(x)+B_{i,-2}(x)+\frac34B_{i,-1}(x)+\frac23B_{i,0}(x)
+ \frac78B_{i,1}(x) +
\frac52B_{i,2}(x) +\frac{19}{10}B_{i,3}(x),\]</span> where <span class="math inline">\(x\in[t_0,t_4]\)</span> and <span class="math inline">\(t_0=0\)</span>, <span class="math inline">\(t_k =
t_{k-1}+6\)</span> ,<span class="math inline">\(k=1,2,3,4\)</span>.</p>
</div>
<div id="basis2fun" class="section level4">
<h4>basis2fun</h4>
<p>A generic function “basis2fun” is provide for class “Fourier_series”
and “bspline_series”. When applied to “Fourier_series” object, it is
equivalent to method “FourierSeries2fun”. When applied to
“bspline_series” object, it is equivalent to method
“bsplineSeries2fun”.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">basis2fun</span>(fsc,<span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.05</span>))</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">#&gt;  [1]  2.1666667  3.1712610  3.6252757  3.4344848  2.7346112  1.8333333</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co">#&gt;  [7]  1.0888125  0.7715265  0.9623175  1.5254623  2.1666667  2.5532270</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#&gt; [13]  2.4497052  1.8164508  0.8324982 -0.1666667 -0.8133005 -0.8465074</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#&gt; [19] -0.2132530  0.9074283  2.1666667</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="fu">basis2fun</span>(bss,<span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">24</span>,<span class="fl">0.5</span>))</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt;  [1] 2.0000000 1.7677509 1.5690908 1.4011502 1.2610597 1.1459499 1.0529514</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">#&gt;  [8] 0.9791948 0.9218107 0.8779297 0.8446824 0.8191993 0.7986111 0.7805266</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt; [15] 0.7644676 0.7504340 0.7384259 0.7284433 0.7204861 0.7145544 0.7106481</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt; [22] 0.7087674 0.7089120 0.7110822 0.7152778 0.7216857 0.7312404 0.7450629</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">#&gt; [29] 0.7642747 0.7899969 0.8233507 0.8654574 0.9174383 0.9804145 1.0555073</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co">#&gt; [36] 1.1438380 1.2465278 1.3634786 1.4897151 1.6190430 1.7452675 1.8621942</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co">#&gt; [43] 1.9636285 2.0433759 2.0952418 2.1130317 2.0905511 2.0216053 1.9000000</span></span></code></pre></div>
</div>
</div>
<div id="eigenfunction-basis" class="section level3">
<h3>Eigenfunction basis</h3>
<p>Suppose <span class="math inline">\(K(s,t)\in L^2(\Omega\times
\Omega)\)</span>, <span class="math inline">\(f(t)\in
L^2(\Omega)\)</span>. Then <span class="math inline">\(K\)</span>
induces an linear operator <span class="math inline">\(\mathcal{K}\)</span> by <span class="math display">\[(\mathcal{K}f)(x) = \int_{\Omega}
K(t,x)f(t)dt\]</span> If <span class="math inline">\(\xi(\cdot)\in
L^2(\Omega)\)</span> s.t. <span class="math display">\[\mathcal{K}\xi =
\lambda \xi\]</span> where <span class="math inline">\(\lambda\in
C\)</span>, then we call <span class="math inline">\(\xi\)</span> a
eigenfunction/eigenvector of <span class="math inline">\(\mathcal{K}\)</span> and <span class="math inline">\(\lambda\)</span> a eigenvalue associated with
<span class="math inline">\(\xi\)</span>.</p>
<p>All the eigenfunctions of <span class="math inline">\(\mathcal{K}\)</span> make a basis of <span class="math inline">\(L^2(\Omega)\)</span>. We call the basis induced by
<span class="math display">\[K(s,t)=\text{Cov}(X(t),X(s))\]</span> a
functional principal component (FPCA) basis, where <span class="math inline">\(\{X(t),t\in\Omega\}\)</span> is a stochastic
process.</p>
</div>
<div id="basis-expansion-methods-for-functional_variable-class" class="section level3">
<h3>Basis expansion methods for “functional_variable” class</h3>
<p>The pakcage MECfda provide method “fourier_basis_expansion” and
“bspline_basis_expansion” for class “functional_variable” to do basis
expansion using Fourier basis and b-spline basis respectively</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">0.0</span>)</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>fv <span class="ot">=</span> MECfda.data.sim.<span class="fl">0.0</span><span class="sc">$</span>FC[[<span class="dv">1</span>]]</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>BE.fs <span class="ot">=</span> <span class="fu">fourier_basis_expansion</span>(fv,<span class="dv">5</span><span class="dt">L</span>)</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>BE.bs <span class="ot">=</span> <span class="fu">bspline_basis_expansion</span>(fv,<span class="dv">5</span><span class="dt">L</span>,<span class="dv">3</span><span class="dt">L</span>)</span></code></pre></div>
</div>
</div>
<div id="numerical-computation-of-integrals" class="section level2">
<h2>Numerical Computation of Integrals</h2>
<p>We use <span class="math display">\[\frac{1}{|T|}\sum_{t\in T}
\rho_{k}(t) X_{i}(t)\]</span> to compute the integral <span class="math display">\[\int_{\Omega} \rho_{k}(t) X_{i}(t) dt\]</span>
where <span class="math inline">\(T\)</span> is the measurement (time)
points of <span class="math inline">\(X_{i}(t)\)</span>, <span class="math inline">\(|T|\)</span> represents the cardinal number of
<span class="math inline">\(T\)</span>.</p>
</div>
</div>
<div id="scalar-on-function-linear-regression-in-mecfda" class="section level1">
<h1>Scalar-on-function Linear Regression in MECfda</h1>
<div id="fcregression" class="section level2">
<h2>fcRegression</h2>
<p>The MECfda package provides a function “fcRegression” to fit
generalized linear mixed effect models, including ordinary linear model,
generalized linear model with fixed and random effect, using basis
expansion to discretize the function-valued covariates. The function
“fcRegression” can solve a linear model in the following form: <span class="math display">\[g(E(Y_i|X_i,Z_i)) = \sum_{l=1}^{L}
\int_{\Omega_l} \beta_l(t) X_{li}(t) dt + (1,Z_i^T)\gamma.\]</span> The
funciton can allow one or multiple function-valued covariate(s) as fixed
effect(s), and zero, one, or multiple scalar-valued covariate(s) as
fixed or random effect(s). Response variable, function-valued
covariate(s), and scalar-valued covariate(s) are input separately as
three different arguements, “Y”, “FC”, and “Z” respectively. The format
of the input data can be very flexible. For response variable, the input
format can be an atomic vector, a one-column matrix or data frame.
Recommended form is a one-column data frame or matrix with column name,
because in this case, the name of response variable is specified. For
input data of function-valued covariate(s), a “functional_variable”
object or a matrix or a data frame or a list of these object(s) can be
accepted. When one “functional_variable” object or a matrix or a data
frame is input as argument “FC”, there is only one function-valued
covariate in the model. When list of these object(s) is input as
argument “FC”, the model can have multiple function-valued covariates,
each element of the list is correspondent to a function-valued
covariate. For input data of scalar-valued covariates, a matrix, data
frame, atomic vector, NULL or, not input can be accepted. When not
assign input value for argument “Z”, there is no scalar-valued covariate
in the model and argument “formula.Z” should also be NULL or not input.
When an atomic vector is input as argument “Z”, there is only one
scalar-valued in the model. And in this case, the name of the
scalar-valued covariate is not specified. So even if there is only one
scalar-valued covariate, a matrix or data frame with colname is
recommended to be input as argument “Z”. Argument formula.Z is used to
specify which part of the argument “Z” is used and how to treat the
scalar-valued covariates, whether to use them as fixed effects or random
effects. Argument “family” can specify the distribution type of response
variable and link function to be used in the regression. Argument
“basis.type” indicate the type of basis function to be used in basis
expansion process. Available options are ‘Fourier’ and ‘Bspline’,
represent Fourier basis and b-spline basis respectively. Argument
“basis.order” indicates number of the function basis to be used. When
using Fourier basis <span class="math inline">\(\frac{1}{2},\sin k t,
\cos k t, k = 1,\dots,p_f\)</span>, “basis.order” is the number <span class="math inline">\(p_f\)</span>. When using b-splines basis <span class="math inline">\(\{B_{i,p}(x)\}_{i=-p}^{k}\)</span>, “basis.order”
is the number of splines, equal to <span class="math inline">\(k+p+1\)</span>. Argument “bs_degree” specify the
degree of the piecewise polynomials of b-spline basis function if use
b-splines basis. This argument is need only when using b-spline
basis.</p>
<p>The function “fcRegression” returns an object of s3 class
“fcRegression”. It is a list that contains following elements.</p>
<ol style="list-style-type: decimal">
<li>regression_result: result of the regression.</li>
<li>FC.BasisCoefficient: a list of Fourier_series or bspline_series
object(s), represents the functional linear coefficient(s) of the
functional covariates.</li>
<li>function.basis.type: type of funtion basis used.</li>
<li>basis.order: same as in the arguemnets.</li>
<li>data: original data.</li>
<li>bs_degree: degree of the splines, returned only if b-splines basis
is used.</li>
</ol>
<p>We can use method “predict” to get predicted value from the model and
use method “fc.beta” to get the value of function-valued linear
coefficient parameters <span class="math inline">\(\beta_l(t)\)</span>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">0.0</span>)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">fcRegression</span>(<span class="at">FC =</span> MECfda.data.sim.<span class="fl">0.0</span><span class="sc">$</span>FC, </span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>                   <span class="at">Y=</span>MECfda.data.sim.<span class="fl">0.0</span><span class="sc">$</span>Y, </span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>                   <span class="at">Z=</span>MECfda.data.sim.<span class="fl">0.0</span><span class="sc">$</span>Z,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>                   <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> <span class="st">&quot;identity&quot;</span>),</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>                   <span class="at">basis.order =</span> <span class="dv">5</span>, <span class="at">basis.type =</span> <span class="fu">c</span>(<span class="st">&#39;Bspline&#39;</span>),</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>                   <span class="at">formula.Z =</span> <span class="sc">~</span> Z_1 <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>Z_2))</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>t <span class="ot">=</span> (<span class="dv">0</span><span class="sc">:</span><span class="dv">100</span>)<span class="sc">/</span><span class="dv">100</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x =</span> t, <span class="at">y =</span> <span class="fu">fc.beta</span>(res,<span class="dv">1</span>,t), <span class="at">ylab =</span> <span class="fu">expression</span>(beta[<span class="dv">1</span>](t)))</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAtFBMVEUAAAAAADoAAGYAOjoAOpAAZrY6AAA6ADo6AGY6OgA6Ojo6OmY6ZpA6ZrY6kNtmAABmADpmAGZmOgBmOjpmOmZmOpBmZmZmZpBmkJBmkLZmkNtmtttmtv+QOgCQZgCQZjqQZmaQtpCQttuQ2/+2ZgC2Zjq2kGa2kJC2ttu229u22/+2///bkDrbkGbbtmbbtpDbtrbb27bb29vb2//b////tmb/25D/27b/29v//7b//9v////+yz6MAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAI9ElEQVR4nO2dDXvTNhRG1Q26UWBsYytj0MFG2WBkZRTSrtH//1+LPxM7ll9d6cpW3fc8D8VuIlk5vbqSHDsxloxi5m5A7lAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAsgEbc5MyVcfEjUnP0SCVua7amPdbCwfiaDNWatlde9LgsbkiETQzZOXzeb6znQy5Qgyt4YUgrY5qA4hZw7yrU7WyASkEbTtZNUrc2Ygr+pKN8I/pDaJBGlU15qpLek2wJd8BVXRU2my5f+6LfAktaCVYxRD1bUpMihhKjJxBPm+1v3waTbnCaI8u1iTezrRM08QZSlol3YqIa2iGYIoR0FmoEdVfmYYzTIUtAuf3m9n6WVJBDXTxALxKLZLzwcPNP1M0JRo0kTQ5gytUZ3V1T3JDgTKLHkoURfbnN0PrK4dwBwPTm0oVQ5am5ejj49EkFOPreJr2jyUW5KuXvtYhqoiTLc1I2QmqJkfjhQc6YEpyEtQNUKNj1POHJ6GzAQ1pzfGSprhWUAiMhNkPbpPHT93UVDTw1DZKdNQXoI8lxJTpqGcBNUdx+tk42RpKCNBpgkNj9LTpaG8BHlnlno+OYGhnARJ5sgSm1FkJUgQEz4zJhXyESQ8X4gXJTpkJAgsUweeP0UMZSPIe4zf1YDXbQrkIkgwxrdFJulkEwtyvnEYMipJO2UQ2URQyIudYqzPRJCxIW9XTJGn8xAUGApT5Ol8BIUcYoI8fbsFpczTzXUB3s9XPvxha4KOkCxPm71/3gWUj7+/F/oiU+XpNqazEBTcw9Ll6VBBn16fbHn2XqkB/daEVJQmT4cJunjQzIO/fqHSgGYnJtUmytMBOWjz9uiX95+L7f8+/fngcdw9GKazHXVRS6K5kHwUe/tif//icdzhu5sxfcT3vRBppfWGd4l/3nR/cfVrVAP6mxGC5CcCfOqUtst87v/m35FOBm+oUxQkP5WEa9z9lI1iN99XYYRucsI31HVyUOgssVOBZghFC3JdP1/jczvU/mbsi1PvZIGCznenu8ZvtPS4oc70tiINaXeykBxU/GgiCCCKIA1B6iOZCRjFJPVLbqjTESSb1OHq2sr8Bf3VC4Wb5yPPFtxQp3PNoeqq3hz89Cl086zzYq9/irpb1+xtaLww1VV9mCB7/fRxOxe6fvXwb4U2KHUwq7yqDxRkN6+2q9ST06cn2zXrI8+lGLqhTkuQ7qo+KAcVP65fHReNOHoUGj4H74upCdJc1R820KdQ/f/m8lKlDfsbmn92jWC0vfZ5l1Jk1wC9sUdpLtQN6kSCvBeritMXrQXHFIK8F6t6KciqLThiBTVzwJH1qv9SQ1WQVifrnF0IiCC8IPNfrCoLUumx3bMLIV1sjT4TSLBYVV1CqQxkvb/ZzItV5bPJGn1sEkG+i1Xd+NEZyKIEbd59sRfbyXTkez5NdboZqKwrfsHRO7sgErQ+Nke/P/zj8uOP0R/dlkhQ/Kq+f3ZBtFg9e2Gvfy6C5+rb2E8mSyYoMlEfNEki6OaHD+U/W/+MIU0OstGdLE5QMQEql6prnS5m9U4C7tUctaqPEmRXR6cVJ6enz99FJeqqiyW5eC6yj/XepJONYh+fnrTEfUCisUk6WFl1zGTo4E26GU93JEjRe1WHGTps0wIFxazq74agiE52mOFnFJQqB0Ws6gcu5ZpTULr7LExY5UPFZhWUjMAFx1CnX6igsMnQ0BxzmYLCFhyDF5NOLOjgjcNUBCw4hhPXQiMoJE8PTzuWK0icp83ghTjLFSTO08NCFytInKcdT1+uIGmedqx8FixImKcdPhctSJKnXXfULFqQIIacz1yyoPbEkMfBhsd4u3BB9ZuAPjHknBMsW5D3h525R7yFC2pjCD3LGWiJBEnuF0uLacNo7DnuWXcaQbL7xZJSBgZIQ2PzgSSCZPeLJcYjDY3NBpIIEt0vlhyYhkbXJMuPoHYZ6jrk+FQgVQ7S+gI2DSo7rjMfTfxMKkjpC9i0qP0MD+Ngtr30eVB9tMbQ4WIdZai7Ici2XzfRO241BxibJqUWFPoFbNrUdnqKxvpe8xTvI0S0Ln11Hgesl+t7NtrcjeZIfgeIal7q6nyOaHb9rH1zDi/2JxY02RuHzmPbviHQlrsTQXYvJXdVjZfxrjy6eSmr8z1qN3p8PjUk0Vps14xMRrH2uP1MBAt41yxpRsQXsKWmm4Y8nu9dsagZ4V/Alh5B+Nh0OSj4C9hyY7YkfWuYSZBfpehc+5y1Rz69YO+8WWClFBT3OAVRUNzjFLRwQfGVUlDc4xR05wUtCQoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFATQFLQ25ujN4I68+JZz9MGXI8VXxoB38HxRFLTetm/dtLGzIy9e7LsvFYXFV8WOjiE9QdWZ2PP7hzvy4ra8UkIiqHf0+8Kju9ETdHVc/MXqixc7O/Lixda93ySCOsUzFfRNEd/1PQqdHXnxcleUg7rFs+xiVQKo00BnR1687DEiQb0DyocIF5kKKu4FiRB0vo2kq+PoT4UsyLOLlTvhXUyeAd3kmaRX9TUq/lmkU1wev26yHeaFEdQpXtmSxK+bfCeKwpl0p3iWOajsGEULq1nISjyOdIpb8VKjU7z41j0VP1ysIigIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEGAWyBorXM9byD5C9r7kOY5oCBA9oKujkc+fHgCshfECEJQEICCABQEoCAABQFunuhcrhpI/oLsOedBOUNBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQH+B0nlgjq469h7AAAAAElFTkSuQmCC" /><!-- --></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x =</span> t, <span class="at">y =</span> <span class="fu">fc.beta</span>(res,<span class="dv">2</span>,t), <span class="at">ylab =</span> <span class="fu">expression</span>(beta[<span class="dv">2</span>](t)))</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">1.0</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="fu">predict</span>(<span class="at">object =</span> res, <span class="at">newData.FC =</span> MECfda.data.sim.<span class="fl">1.0</span><span class="sc">$</span>FC,</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>        <span class="at">newData.Z =</span> MECfda.data.sim.<span class="fl">1.0</span><span class="sc">$</span>Z)</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">#&gt;        1        2        3        4        5 </span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">#&gt; 6.500129 5.690171 2.388979 5.441011 4.821000</span></span></code></pre></div>
</div>
<div id="fcqr" class="section level2">
<h2>fcQR</h2>
<p>The MECfda package provides a function “fcQR” to fit quantile linear
regression models. The method to deal with function-valued covariates is
also discretization using basis expansion. The function “fcQR” can solve
a linear model in the following form: <span class="math display">\[Q_{Y_i|X_i,Z_i}(\tau) =
\sum_{l=1}^L\int_{\Omega_l} \beta_l(\tau,t) X_{li}(t) dt
+  (1,Z_i^T)\gamma.\]</span> The funciton can allow one or multiple
function-valued covariate(s), and zero, one, or multiple scalar-valued
covariate(s). The way and rules to input the data is exact the same as
function “fcRegression”. How to treat the scalar-valued covariates is
also specified by the argument “formula.Z”, similar to in function
“fcRegression”. The only difference is that there is no random effect in
quantile linear regression model. The quantile <span class="math inline">\(\tau\)</span> is specified by the argument “tau”.
The type and parameters of the basis function are also specified by
argument “basis.type”, “basis.order”, and “bs_degree” as in function
“fcRegression”.</p>
<p>The function “fcQR” returns an object of s3 class “fcQR”. It is a
list that contains contains the following elements.</p>
<ol style="list-style-type: decimal">
<li>regression_result: Result of the regression.</li>
<li>FC.BasisCoefficient: A list of Fourier_series or bspline_series
object(s), represents the functional linear coefficient(s) of the
functional covariates.</li>
<li>function.basis.type: Type of funtion basis used.</li>
<li>basis.order: Same as in the arguemnets.</li>
<li>data: Original data.</li>
<li>bs_degree: Degree of the splines, returned only if b-splines basis
is used.</li>
</ol>
<p>We can use method “predict” to get predicted value from the model and
use method “fc.beta” to get the value of function-valued linear
coefficient parameters <span class="math inline">\(\beta_l(t)\)</span>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">0.0</span>)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">fcQR</span>(<span class="at">FC =</span> MECfda.data.sim.<span class="fl">0.0</span><span class="sc">$</span>FC, </span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>           <span class="at">Y=</span>MECfda.data.sim.<span class="fl">0.0</span><span class="sc">$</span>Y, </span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>           <span class="at">Z=</span>MECfda.data.sim.<span class="fl">0.0</span><span class="sc">$</span>Z,</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>           <span class="at">tau =</span> <span class="fl">0.5</span>,</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>           <span class="at">basis.order =</span> <span class="dv">5</span>, <span class="at">basis.type =</span> <span class="fu">c</span>(<span class="st">&#39;Bspline&#39;</span>),</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>           <span class="at">formula.Z =</span> <span class="sc">~</span> .)</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>t <span class="ot">=</span> (<span class="dv">0</span><span class="sc">:</span><span class="dv">100</span>)<span class="sc">/</span><span class="dv">100</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x =</span> t, <span class="at">y =</span> <span class="fu">fc.beta</span>(res,<span class="dv">1</span>,t), <span class="at">ylab =</span> <span class="fu">expression</span>(beta[<span class="dv">1</span>](t)))</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x =</span> t, <span class="at">y =</span> <span class="fu">fc.beta</span>(res,<span class="dv">2</span>,t), <span class="at">ylab =</span> <span class="fu">expression</span>(beta[<span class="dv">2</span>](t)))</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">1.0</span>)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="fu">predict</span>(<span class="at">object =</span> res, <span class="at">newData.FC =</span> MECfda.data.sim.<span class="fl">1.0</span><span class="sc">$</span>FC,</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>        <span class="at">newData.Z =</span> MECfda.data.sim.<span class="fl">1.0</span><span class="sc">$</span>Z)</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co">#&gt;        1        2        3        4        5 </span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co">#&gt; 6.497759 5.682573 2.404464 5.440699 4.830085</span></span></code></pre></div>
</div>
</div>
<div id="measurement-error-models-and-bias-correction-estimation-methods" class="section level1">
<h1>Measurement Error Models and Bias Correction Estimation Methods</h1>
<p>Data in real world often have measurement error, especially for
function-valued data. And measurement error in data set may lead to bias
in estimation. Package MECfda also provides functions of bias correction
estimation method for some certain linear regression models with
measurement error.</p>
<div id="me.fcregression_mem" class="section level3">
<h3>ME.fcRegression_MEM</h3>
<p>Luan et. al.  proposed a mixed effect model based bias correction
estimation method for scalar-on-function generalied linear regression
model with measurement error. <span class="citation">(Luan et al.
2023)</span> Their statistical model is as follow: <span class="math display">\[\begin{align*}
  &amp;g(E(Y_i|X_i,Z_i)) = \int_{\Omega} \beta(t) X_{i}(t) dt +
(1,Z_i^T)\gamma\\
  &amp;h(E(W_{ij}(t)|X_i(t))) = X_i(t)\\
  &amp;X_i(t) = \mu_x(t) + \varepsilon_{xi}(t)
\end{align*}\]</span> where response variable <span class="math inline">\(Y_i\)</span> and scalar-valued covariates <span class="math inline">\(Z_i\)</span> are measured without error,
function-valued covariate <span class="math inline">\(X_i(t)\)</span> is
repeatedly measured with error as <span class="math inline">\(W_{ij}(t)\)</span>. And they have additional
assumption:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(Y_i|X_i,Z_i\sim EF(\cdot)\)</span>,
<span class="math inline">\(EF\)</span> refers to an exponential family
distribution.</li>
<li><span class="math inline">\(g(\cdot)\)</span> and <span class="math inline">\(h(\cdot)\)</span> are known monotone, twice
continuously differentiable functions.</li>
<li><span class="math inline">\(Cov\{X_i(t),W_{ij}(t)\} \neq
0\)</span>,</li>
<li><span class="math inline">\(W_{ij}(t)|X_i(t)\sim
EF(\cdot)\)</span></li>
<li><span class="math inline">\(f_{Y_i|W_{ij}(t),X_i(t)}(\cdot) =
f_{Y_i|X_i(t)}(\cdot)\)</span>, <span class="math inline">\(f\)</span>
refers to PDF.</li>
<li><span class="math inline">\(X_i(t)\sim
GP\{\mu_x(t),\Sigma_{xx}\}\)</span>, <span class="math inline">\(GP\)</span> refers to Gaussian process.</li>
</ol>
<p>They proposed a mixed effects model-based estimation method to
correct the bias caused by the measurement error in the functional
covariate. It allows us to investigate the nonlinear measurement error
model, where the relationship between the true and observed measurements
is not constrained to be linear, and the distribution assumption on the
observed measurement is relaxed to encompass the exponential family
rather than being limited to the Gaussian distribution.</p>
<p>The mixed-effects model-based (MEM) approach is a two stage method
that employs functional mixed-effects models. The first stage of the MEM
approach is to approximate the true measure <span class="math inline">\(X_i(t)\)</span> with the repeated observed
measurement <span class="math inline">\(W_{ij}(t)\)</span> using a
functional mixed-effects model. It is mainly based on the assumption
that <span class="math inline">\(h[E\{W_{ij}(t)|X_i(t)\}] =
X_i(t)\)</span> and <span class="math inline">\(X_i(t) = \mu_x(t) +
\varepsilon_{xi}(t)\)</span>. That is, the random intercept in the
functional mixed-effects model with one fixed-intercept and one random
intercept is assumed to to be the subject-wise deviation of <span class="math inline">\(X_i(t)\)</span> from the mean process <span class="math inline">\(\mu_x(t)\)</span> while the fixed intercept is
assumed to represent <span class="math inline">\(\mu_x(t)\)</span>. The
second stage involves replacing <span class="math inline">\(X_i(t)\)</span> with the resulting approximation
of <span class="math inline">\(X_i(t)\)</span> from the first stage in
the regression model. The MEM approach employs point-wise (UP_MEM) and
multi-point-wise (MP_MEM) estimation procedures to avoid potential
computational complexities caused by analyses of multi-level functional
data and computations of potentially intractable and complex
integrals.</p>
<p>Package MECfda provide a function “ME.fcRegression_MEM” to apply
their bias correction estimation method. Response variable,
function-valued covariate(s), and scalar-valued covariate(s) are input
separately as three different arguments. Argument “data.Y” is the
response variable. Input can be an atomic vector, a one-column matrix or
data frame, recommended form is a one-column data frame with column
name. Argument “data.W” is the data of <span class="math inline">\(W\)</span>, the measurement of <span class="math inline">\(X\)</span>, in the statistical model. The input
should be a 3-dimensional array. Each row represents a subject. Each
column represent a measurement (time) point. Each layer represents an
observation. Argument “data.Z” is the data of scalar covariate(s), It
can be not input or NULL (when there’s no scalar covariate), an atomic
vector (when only one scalar covariate), a matrix or data frame,
recommended form is a data frame with column name(s). Argument “method”
specifies method to construct the substitution <span class="math inline">\(X\)</span>. Available options: ‘UP_MEM’, ‘MP_MEM’,
‘average’. Argument “t_interval” specifies the domain of the
function-valued covariate. It should be a 2-element vector, represents
an interval. Default is c(0,1), represent interval <span class="math inline">\([0,1]\)</span>. Argument “t_points” is the
sequence of the measurement (time) points, default is NULL. Argument d
is the number of time points involved for MP_MEM (default and miniumn is
3). Argument “family.W” is the distribution of <span class="math inline">\(W\)</span> given <span class="math inline">\(X\)</span>. Available options are “gaussian” and
“poisson”. Argument “family.Y” is a description of the error
distribution and link function to be used in the model. See
stats::family. Argument “formula.Z” is used to specify which part of the
argument “Z” is used and how to treat the scalar-valued covariates,
whether to use them as fixed effects or random effects. Argument
“basis.type” indicate the type of basis function to be used in basis
expansion process. Available options are ‘Fourier’ and ‘Bspline’,
represent Fourier basis and b-spline basis respectively. Argument
“basis.order” indicates number of the function basis to be used. When
using Fourier basis <span class="math inline">\(\frac{1}{2},\sin k t,
\cos k t, k = 1,\dots,p_f\)</span>, “basis.order” is the number <span class="math inline">\(p_f\)</span>. When using b-splines basis <span class="math inline">\(\{B_{i,p}(x)\}_{i=-p}^{k}\)</span>, “basis.order”
is the number of splines, equal to <span class="math inline">\(k+p+1\)</span>. Argument “bs_degree” specify the
degree of the piecewise polynomials of b-spline basis function if use
b-splines basis. This argument is need only when using b-spline basis.
Argument “smooth” specifies whether to smooth the substitution of <span class="math inline">\(X\)</span>, default is FALSE. Argument “silent”
specifies whether not to show the state of the running of the function,
default is TRUE.</p>
<p>And the function ME.fcRegression_MEM returns a fcRegression
object.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">0.1</span>)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">ME.fcRegression_MEM</span>(<span class="at">data.Y =</span> MECfda.data.sim.<span class="fl">0.1</span><span class="sc">$</span>Y,</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>                          <span class="at">data.W =</span> MECfda.data.sim.<span class="fl">0.1</span><span class="sc">$</span>W,</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>                          <span class="at">data.Z =</span> MECfda.data.sim.<span class="fl">0.1</span><span class="sc">$</span>Z,</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>                          <span class="at">method =</span> <span class="st">&#39;UP_MEM&#39;</span>,</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>                          <span class="at">family.W =</span> <span class="st">&quot;gaussian&quot;</span>,</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>                          <span class="at">basis.type =</span> <span class="st">&#39;Bspline&#39;</span>)</span></code></pre></div>
</div>
<div id="me.fcqr_iv.simex" class="section level3">
<h3>ME.fcQR_IV.SIMEX</h3>
<p>Tekwe et. al.  proposed a simulation extrapolation (SIMEX) estimation
method to correct the bias in scalar-on-function quantile linear
regression due to measurement error using instrumental variable. <span class="citation">(Tekwe et al. 2022)</span> Their statistical model is
as follow: <span class="math display">\[\begin{align*}
  &amp;Q_{Y_i|X_i,Z_i}(\tau) = \int_{\Omega} \beta(\tau,t) X_{li}(t) dt
+  (1,Z_i^T)\gamma(\tau)\\
  &amp;W_i(t) = X_i(t) + U_i(t)\\
  &amp;M_i(t) = \delta(t) X_i(t) + \eta_i(t)
\end{align*}\]</span> where response variable <span class="math inline">\(Y_i\)</span> and scalar-valued covariates <span class="math inline">\(Z_i\)</span> are measured without error,
function-valued covariate <span class="math inline">\(X_i(t)\)</span> is
measured with error as <span class="math inline">\(W_i(t)\)</span>, and
<span class="math inline">\(M_i(t)\)</span> is an measured instrumental
variable. And they have additional assumption:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(Cov\{X_i(t),U_i(s)\} = 0\)</span>,</li>
<li><span class="math inline">\(Cov\{M_i(t),U_i(s)\} = 0\)</span>,</li>
<li><span class="math inline">\(E(W_{i}(t)|X_i(t)) =
X_i(t)\)</span></li>
<li><span class="math inline">\(U_i(t)\sim
GP\{\mathcal{0},\Sigma_{uu}\}\)</span>, <span class="math inline">\(GP\)</span> refers to Gaussian process.</li>
</ol>
<p>for <span class="math inline">\(\forall t,s\in[0,1]\)</span> and
<span class="math inline">\(i = 1,\dots,n\)</span>.</p>
<p>Their bias correction estimation method performs a two-stage strategy
to correct the measurement error of a function-valued covariate and then
fit a linear quantile regression model. In the first stage, an
instrumental variable is used to estimate the covariance matrix
associated with the measurement error. In the second stage, simulation
extrapolation (SIMEX) is used to correct for measurement error in the
function-valued covariate.</p>
<p>Package MECfda provide a function “ME.fcQR_IV.SIMEX” to apply their
bias correction estimation method. Argument “data.Y” is the response
variable. Input can be an atomic vector, a one-column matrix or data
frame, recommended form is a one-column data frame with column name.
Argument “data.W” is the data of <span class="math inline">\(W\)</span>,
the measurement of <span class="math inline">\(X\)</span>, in the
statistical model. The input should be a dataframe or matrix. Each row
represents a subject. Each column represent a measurement (time) point.
Argument “data.Z” is the data of scalar covariate(s), It can be not
input or NULL (when there’s no scalar covariate), an atomic vector (when
only one scalar covariate), a matrix or data frame, recommended form is
a data frame with column name(s). Argument “data.M” is the data of <span class="math inline">\(M\)</span>, the instrumental variable. Input
should be a dataframe or matrix. Each row represents a subject. Each
column represent a measurement (time) point. Argument “tau” is the
quantile <span class="math inline">\(\tau\in(0,1)\)</span>, default is
0.5. Argument “t_interval” specifies the domain of the function-valued
covariate. It should be a 2-element vector, represents an interval.
Default is c(0,1), represent interval <span class="math inline">\([0,1]\)</span>. Argument “t_points” is the
sequence of the measurement (time) points, default is NULL. Argument
“formula.Z” is used to specify which part of the argument “Z” is used
and how to treat the scalar-valued covariates. Argument “basis.type”
indicate the type of basis function to be used in basis expansion
process. Available options are ‘Fourier’ and ‘Bspline’, represent
Fourier basis and b-spline basis respectively. Argument “basis.order”
indicates number of the function basis to be used. When using Fourier
basis <span class="math inline">\(\frac{1}{2},\sin k t, \cos k t, k =
1,\dots,p_f\)</span>, “basis.order” is the number <span class="math inline">\(p_f\)</span>. When using b-splines basis <span class="math inline">\(\{B_{i,p}(x)\}_{i=-p}^{k}\)</span>, “basis.order”
is the number of splines, equal to <span class="math inline">\(k+p+1\)</span>. Argument “bs_degree” specify the
degree of the piecewise polynomials of b-spline basis function if use
b-splines basis. This argument is need only when using b-spline
basis.</p>
<p>Function “ME.fcQR_IV.SIMEX” returns a ME.fcQR_IV.SIMEX class object.
It is a list that contains the following elements.</p>
<ol style="list-style-type: decimal">
<li>coef.X: A Fourier_series or bspline_series object, represents the
functional coefficient parameter of the functional covariate.</li>
<li>coef.Z: The estimate of the linear coefficients of the scalar
covariates.</li>
<li>coef.all: Original estimate of linear coefficients.</li>
<li>function.basis.type: Type of funtion basis used.</li>
<li>basis.order: Same as in the input arguements.</li>
<li>t_interval: A 2-element vector, represents an interval, means the
domain of the functional covariate.</li>
<li>t_points: Sequence of the measurement (time) points.</li>
<li>formula: Regression model.</li>
<li>formula.Z: formula object contains only the scalar
covariate(s).</li>
<li>zlevels: levels of the non-continuous scalar covariate(s).</li>
</ol>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">rm</span>(<span class="at">list =</span> <span class="fu">ls</span>())</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">0.2</span>)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">ME.fcQR_IV.SIMEX</span>(<span class="at">data.Y =</span> MECfda.data.sim.<span class="fl">0.2</span><span class="sc">$</span>Y,</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>                       <span class="at">data.W =</span> MECfda.data.sim.<span class="fl">0.2</span><span class="sc">$</span>W,</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>                       <span class="at">data.Z =</span> MECfda.data.sim.<span class="fl">0.2</span><span class="sc">$</span>Z,</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>                       <span class="at">data.M =</span> MECfda.data.sim.<span class="fl">0.2</span><span class="sc">$</span>M,</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>                       <span class="at">tau =</span> <span class="fl">0.5</span>,</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>                       <span class="at">basis.type =</span> <span class="st">&#39;Bspline&#39;</span>)</span></code></pre></div>
</div>
<div id="me.fcqr_cls" class="section level3">
<h3>ME.fcQR_CLS</h3>
<p>Zhang et. al.  proposed a corrected loss score estimation method for
scalar-on-function quantile linear regression to correct the bias due to
measurement error. <span class="citation">(Zhang et al. 2023)</span>
Their statistical model is as follow: <span class="math display">\[\begin{align*}
  &amp;Q_{Y_i|X_i,Z_i}(\tau) = \int_{\Omega} \beta(\tau,t) X_{li}(t) dt
+  (1,Z_i^T)\gamma(\tau)\\
  &amp;W_i(t) = X_i(t) + U_i(t)
\end{align*}\]</span> where response variable <span class="math inline">\(Y_i\)</span> and scalar-valued covariates <span class="math inline">\(Z_i\)</span> are measured without error,
function-valued covariate <span class="math inline">\(X_i(t)\)</span> is
measured with error as <span class="math inline">\(W_i(t)\)</span>.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(E[U_i(t)]=0\)</span>.</li>
<li><span class="math inline">\(Cov\{U_i(t),U_i(s)\} =
\Sigma_U(s,t)\)</span>, where <span class="math inline">\(\Sigma_U(s,t)\)</span> is unknown.</li>
<li><span class="math inline">\(U_i(t)\)</span> are i.i.d for different
<span class="math inline">\(i\)</span>.</li>
</ol>
<p>Zhang et al. proposed a new corrected loss function for a partially
functional linear quantile model with functional measurement error in
this manuscript. They established a corrected quantile objective
function of the observed measurement that is an unbiased estimator of
the quantile objective function that would be obtained if the true
measurements were available. The estimators of the regression parameters
are obtained by optimizing the resulting corrected loss function. The
resulting estimator of the regression parameters is shown to be
consistent.</p>
<p>Package MECfda provide a function “ME.fcQR_CLS” to apply their bias
correction estimation method. Argument “data.Y” is the response
variable. Input can be an atomic vector, a one-column matrix or data
frame, recommended form is a one-column data frame with column name.
Argument “data.W” is the data of <span class="math inline">\(W\)</span>,
the measurement of <span class="math inline">\(X\)</span>, in the
statistical model. The input should be a 3-dimensional array. Each row
represents a subject. Each column represent a measurement (time) point.
Each layer represents an observation. Argument “data.Z” is the data of
scalar covariate(s), It can be not input or NULL (when there’s no scalar
covariate), an atomic vector (when only one scalar covariate), a matrix
or data frame, recommended form is a data frame with column name(s).
Argument “tau” is the quantile <span class="math inline">\(\tau\in(0,1)\)</span>, default is 0.5. Argument
“t_interval” specifies the domain of the function-valued covariate. It
should be a 2-element vector, represents an interval. Default is c(0,1),
represent interval <span class="math inline">\([0,1]\)</span>. Argument
“t_points” is the sequence of the measurement (time) points, default is
NULL. Argument “grid_k” is an atomic vector, of which each element is
candidate number of basis. Argument “grid_h” is a non-zero-value atomic
vector, of which each element is candidate value of tunning parameter.
Argument “degree” is Used in computation for derivative and integral,
defult is 45, large enough for most scenario. Argument “observed_X” is
for estimating parametric variance. Default is NULL.</p>
<p>The function returns a ME.fcQR_CLS class object. It is a list that
contains the following elements.</p>
<ol style="list-style-type: decimal">
<li>estimated_beta_hat: Estimated coefficients from corrected loss
function (including functional part)</li>
<li>estimated_beta_t: Estimated functional curve</li>
<li>SE_est: Estimated parametric variance. Returned only if observed_X
is not NULL.</li>
<li>estimated_Xbasis: The basis matrix we used</li>
<li>res_naive: results of naive method</li>
</ol>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">rm</span>(<span class="at">list =</span> <span class="fu">ls</span>())</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">0.1</span>)</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">ME.fcQR_CLS</span>(<span class="at">data.Y =</span> MECfda.data.sim.<span class="fl">0.1</span><span class="sc">$</span>Y,</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>                  <span class="at">data.W =</span> MECfda.data.sim.<span class="fl">0.1</span><span class="sc">$</span>W,</span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>                  <span class="at">data.Z =</span> MECfda.data.sim.<span class="fl">0.1</span><span class="sc">$</span>Z,</span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>                  <span class="at">tau =</span> <span class="fl">0.5</span>,</span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>                  <span class="at">grid_k =</span> <span class="dv">4</span><span class="sc">:</span><span class="dv">7</span>,</span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>                  <span class="at">grid_h =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>)</span></code></pre></div>
</div>
<div id="me.fclr_iv" class="section level3">
<h3>ME.fcLR_IV</h3>
<p>Tekwe et. al.  proposed a bias correction estimation method for
scalar-on-function linear regression model with measurement error using
instrumental variable. <span class="citation">(Tekwe et al. 2019)</span>
Their statistical model is as follow: <span class="math display">\[\begin{align*}
  &amp;Y_i = \int_0^1 \beta(t)X_i(t)dt + \varepsilon_i\\
  &amp;W_i(t) = X_i(t) + U_i(t)\\
  &amp;M_i(t) = \delta X_i(t) + \eta_i(t)
\end{align*}\]</span> where response variable <span class="math inline">\(Y_i\)</span> and are measured without error,
function-valued covariate <span class="math inline">\(X_i(t)\)</span> is
measured with error as <span class="math inline">\(W_i(t)\)</span>, and
<span class="math inline">\(M_i(t)\)</span> is an measured instrumental
variable. And they have additional assumption:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(E\varepsilon_i(t) = 0\)</span>,</li>
<li><span class="math inline">\(EU_i(t) = 0\)</span>,</li>
<li><span class="math inline">\(E\eta_i(t) = 0\)</span>,</li>
<li><span class="math inline">\(Cov\{X_i(t),\varepsilon_i\} =
0\)</span>,</li>
<li><span class="math inline">\(Cov\{M_i(t),\varepsilon_i\} =
0\)</span>,</li>
<li><span class="math inline">\(Cov\{M_i(t),U_i(s)\} = 0\)</span>,</li>
</ol>
<p>for <span class="math inline">\(\forall t,s\in[0,1]\)</span> and
<span class="math inline">\(i = 1,\dots,n\)</span>.</p>
<p>Package MECfda provide a function “ME.fcLR_IV” to apply their bias
correction estimation method. Argument “data.Y” is the response
variable. Input can be an atomic vector, a one-column matrix or data
frame, recommended form is a one-column data frame with column name.
Argument “data.W” is the data of <span class="math inline">\(W\)</span>,
the measurement of <span class="math inline">\(X\)</span>, in the
statistical model. The input should be a dataframe or matrix. Each row
represents a subject. Each column represent a measurement (time) point.
Argument “data.M” is the data of <span class="math inline">\(M\)</span>,
the instrumental variable. Input should be a dataframe or matrix. Each
row represents a subject. Each column represent a measurement (time)
point. Argument “t_interval” specifies the domain of the function-valued
covariate. It should be a 2-element vector, represents an interval.
Default is c(0,1), represent interval <span class="math inline">\([0,1]\)</span>. Argument “t_points” is the
sequence of the measurement (time) points, default is NULL. Argument
“CI.bootstrap” specifies whether to return the confidence using
bootstrap method. Default is FALSE.</p>
<p>The function returns a ME.fcLR_IV class object. It is a list that
contains the following elements.</p>
<ol style="list-style-type: decimal">
<li>beta_tW: parameter estimates.</li>
<li>CI: confidence interval, returned only when CI.bootstrap is
TRUE.</li>
</ol>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">rm</span>(<span class="at">list =</span> <span class="fu">ls</span>())</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="fu">data</span>(MECfda.data.sim.<span class="fl">0.3</span>)</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">ME.fcLR_IV</span>(<span class="at">data.Y =</span> MECfda.data.sim.<span class="fl">0.3</span><span class="sc">$</span>Y,</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>                 <span class="at">data.W =</span> MECfda.data.sim.<span class="fl">0.3</span><span class="sc">$</span>W,</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>                 <span class="at">data.M =</span> MECfda.data.sim.<span class="fl">0.3</span><span class="sc">$</span>M)</span></code></pre></div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-luan2023scalable" class="csl-entry">
Luan, Yuanyuan, Roger S Zoh, Erjia Cui, Xue Lan, Sneha Jadhav, and
Carmen D Tekwe. 2023. <span>“Scalable Regression Calibration Approaches
to Correcting Measurement Error in Multi-Level Generalized Functional
Linear Regression Models with Heteroscedastic Measurement
Errors.”</span> <em>arXiv Preprint arXiv:2305.12624</em>.
</div>
<div id="ref-tekwe2022estimation" class="csl-entry">
Tekwe, Carmen D, Mengli Zhang, Raymond J Carroll, Yuanyuan Luan, Lan
Xue, Roger S Zoh, Stephen J Carter, David B Allison, and Marco Geraci.
2022. <span>“Estimation of Sparse Functional Quantile Regression with
Measurement Error: A SIMEX Approach.”</span> <em>Biostatistics</em> 23
(4): 1218–41.
</div>
<div id="ref-tekwe2019instrumental" class="csl-entry">
Tekwe, Carmen D, Roger S Zoh, Miao Yang, Raymond J Carroll, Gilson
Honvoh, David B Allison, Mark Benden, and Lan Xue. 2019.
<span>“Instrumental Variable Approach to Estimating the
Scalar-on-Function Regression Model with Measurement Error with
Application to Energy Expenditure Assessment in Childhood
Obesity.”</span> <em>Statistics in Medicine</em> 38 (20): 3764–81.
</div>
<div id="ref-zhang2023partially" class="csl-entry">
Zhang, Mengli, Lan Xue, Carmen D Tekwe, Yang Bai, and Annie Qu. 2023.
<span>“PARTIALLY FUNCTIONAL LINEAR QUANTILE REGRESSION WITH MEASUREMENT
ERRORS.”</span> <em>Statistica Sinica</em> 33: 2257–80.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
